//@author: a0126720n



	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\ActionException.java
	 */


public class ActionException extends Exception {
	private static final long serialVersionUID = -761775751042015925L;
	
	private List<Task> options;
	private ErrorLocation location;
	private List<Subcommand> subcommands;
	
	public enum ErrorLocation {
		DELETE, EDIT, FINISH, ADD, REPEAT, UNDO, UNFINISH;
		
		public String toString() {
			return this.name().toLowerCase();
		}
	}

	public ActionException(List<Task> taskList, ErrorLocation loc, List<Subcommand> sc) {
		options = taskList;
		location = loc;
		subcommands = sc;
	}
	
	
	public List<Task> getOptions() {
		return options;
	}
	
	public ErrorLocation getLocation() {
		return location;
	}
	
	public List<Subcommand> getSubcommands() {
		return subcommands;
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\ActionException.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\BadCommandException.java
	 */


@SuppressWarnings("serial")
public class BadCommandException extends Exception {
	public BadCommandException(String args) {
		super(args);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\BadCommandException.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\BadSubcommandArgException.java
	 */


@SuppressWarnings("serial")
public class BadSubcommandArgException extends Exception {
	public BadSubcommandArgException(String args) {
		super(args);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\BadSubcommandArgException.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\BadSubcommandException.java
	 */


@SuppressWarnings("serial")
public class BadSubcommandException extends Exception {
	public BadSubcommandException(String args) {
		super(args);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\BadSubcommandException.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java
	 */

	public boolean dateValid(int userday, int usermonth, int useryear) {
		SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");  
	    sdf.setLenient(false);
	    Calendar cal = Calendar.getInstance();  
	    try{
	    	cal.setTime(sdf.parse(usermonth + "/" + userday + "/" + useryear));
	    } catch(Exception e) {
	    	return false;
	    }
		
		boolean dateIsValid = true;
		try {
			if (useryear < 2014 || useryear > 9999) {
				dateIsValid = false;
			}
		} catch (DateTimeException e) {
			dateIsValid = false;
		}
		return dateIsValid;
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java
	 */

	public boolean isBefore(Date other) {
		boolean answer = false;
		if (other.year > year) {
			answer = true;
		} else if (other.year == year) {
			if (other.month > month) {
				answer = true;
			} else if (other.month == month) {
				if (other.day > day) {
					answer = true;
				}
			}
		}
		return answer;
	}

	/**
	 * 
	 * @param another
	 * @return
	 */
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java
	 */

	public static String getFormat() {
		if (dmFormat) {
			return "d/m";
		} else {
			return "m/d";
		}
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java
	 */

	private static String cleanUpYear(String year) {
		String space = " ";
		String comma = ",";
		String emptyString = new String();

		if (year.contains(space)) {
			year = year.replace(space, emptyString);
		}

		if (year.contains(comma)) {
			year = year.replace(comma, emptyString);
		}

		return year;
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java
	 */

	/**
	 * corrects a 2-digit year to be a 4-digit year. Assumes that the 
	 * lifetime of this product will not extend past the 21st century
	 * @param useryear
	 * @return
	 */
	private int correctYear(int year) {
		if (year > 0 && year < 100) {
			return 2000 + year;
		}
		
		return year;
	}
	
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Date.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\NoResultException.java
	 */


@SuppressWarnings("serial")
public class NoResultException extends Exception {
	public NoResultException(String args) {
		super(args);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\NoResultException.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\sortTaskByEndDate.java
	 */

public class sortTaskByEndDate implements Comparator<Task> {
	    public int compare(Task first, Task second) {
	        int endDateResults = compareEndDate(first, second);
	    	if (endDateResults != 0) {
	    		return endDateResults;
	    	}
	    	
	    	int endTimeResults = compareEndTime(first, second);
	    	if (endTimeResults != 0) {
	    		return endTimeResults;
	    	}
	    	
	    	int startDateResults = compareStartDate(first, second);
	    	if (startDateResults != 0) {
	    		return startDateResults;
	    	}
	    	
	    	int startTimeResults = compareStartTime(first, second);
	    	if (startTimeResults != 0) {
	    		return startTimeResults;
	    	}
	    	
	    	else return first.getName().compareTo(second.getName());
	    }

		private int compareStartTime(Task first, Task second) {
			if (!first.hasStartTime() && !second.hasStartTime()) {
				return 0;
			} else if (first.hasStartTime() && !second.hasStartTime()) {
				return -1;
			} else if (!first.hasStartTime() && second.hasStartTime()) {
				return 1;
			} 
			
			return first.getStartTime().compareTo((second.getStartTime()));
		}

		private int compareStartDate(Task first, Task second) {
			if (!first.hasStartTime() && !second.hasStartTime()) {
				return 0;
			} else if (first.hasStartTime() && !second.hasStartTime()) {
				return -1;
			} else if (!first.hasStartTime() && second.hasStartTime()) {
				return 1;
			} else if (first.getStartDate().isBefore(second.getStartDate())) {
				return -1;
			} else if (first.getStartDate().isEquals((second.getStartDate()))) {
				return 0;
			} else {
				return 1;
			}
		}

		private int compareEndTime(Task first, Task second) {
			if (!first.hasEndTime() && !second.hasEndTime()) {
				return 0;
			} else if (first.hasEndTime() && !second.hasEndTime()) {
				return -1;
			} else if (!first.hasEndTime() && second.hasEndTime()) {
				return 1;
			} 
			
			return first.getEndTime().compareTo((second.getEndTime()));
		}

		private int compareEndDate(Task first, Task second) {
			if (!first.getHasDeadline() && !second.getHasDeadline()) {
				return 0;
			} else if (first.getHasDeadline() && !second.getHasDeadline()) {
				return -1;
			} else if (!first.getHasDeadline() && second.getHasDeadline()) {
				return 1;
			} else if (first.getEndDate().isBefore(second.getEndDate())) {
				return -1;
			} else if (first.getEndDate().isEquals((second.getEndDate()))) {
				return 0;
			} else {
				return 1;
			}
		}
		
		
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\sortTaskByEndDate.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\SuffixTree.java
	 */


package dataEncapsulation;

import java.util.ArrayList;
import java.util.List;

public class SuffixTree {
	private List<SuffixTree> tree;

	private String match;
	private boolean isRoot = false;

	private static final String EMPTY_STRING = "";

	public SuffixTree() {
		match = EMPTY_STRING;
		isRoot = true;
		tree = new ArrayList<SuffixTree>();
	}

	public void add(String string) {
		if (string == null || (string.isEmpty() && isRoot)) {
			return;
		}
		
		if (string.isEmpty() && tree.isEmpty()) {
			return;
		}
		
		if (tree.isEmpty()) {
			initializeTree(string);
			return;
		}

		String newChar = getFirstCharString(string);

		int index = 0;
		for (; index < tree.size(); ++index) {
			String currentChar = tree.get(index).match;

			int comparison = newChar.compareTo(currentChar);
			int equal = 0;

			if (comparison > equal ) {
				// do nothing, keep going
			} else if (comparison < equal) {
				insertBefore(string, index);
				return;
			} else if (comparison == equal && !newChar.isEmpty()) {
				tree.get(index).add(getAfterFirstChar(string));
				return;
			}
		}

		// made it out of the loop, insert at end
		if (!newChar.isEmpty()) {
			insertAtEnd(string);
		}
	}

	public void remove(String string) {
		string = string.toLowerCase();
		
		if (string.isEmpty() && tree.isEmpty()) {
			return;
		}
		
		if (tree.size() == 1) {
			deleteFinalBranch(string);
			deleteIfSubtreeIsEmpty(0);
			return;
		}
		
		String firstChar = getFirstCharString(string);
		
		for (int i = 0; i < tree.size(); ++i) {
			SuffixTree subTree = tree.get(i);
			
			if (firstChar.equalsIgnoreCase(subTree.match)) {
				String stringMinusFirstChar = getAfterFirstChar(string);
				subTree.remove(stringMinusFirstChar);
				
				// if calling remove deleted everything in the subtree, 
				//delete subtree
				deleteIfSubtreeIsEmpty(i);
			}
		}
		
		return;
	}

	public List<String> getMatchList(String key) {
		return getMatchList(key, EMPTY_STRING);
	}
	
	private void deleteIfSubtreeIsEmpty(int i) {
		if (tree.size() <= i) {
			return;
		}
		
		SuffixTree subTree = tree.get(i);
		
		if (subTree.tree.isEmpty()) {
			tree.remove(i);
		}
	}
	
	private boolean deleteFinalBranch(String string) {
		boolean shouldDelete = true;
		
		if (tree.size() != 1) {
			remove(string);	// tree splits further down, don't delete path
			return false;
		} else if (tree.get(0).tree.isEmpty() && string.isEmpty()) {
			return true;	// complete match
		} else if (string.isEmpty()) {
			return false;	// string terminated early, not a match
		} else if (tree.get(0).tree.isEmpty() && !string.isEmpty()) {
			return false;	// string did not terminate at end of tree
		}
		
		SuffixTree nextTree = tree.get(0);
		String withoutFirst = getAfterFirstChar(string);
		shouldDelete = nextTree.deleteFinalBranch(withoutFirst);
		
		if (shouldDelete) {
			tree.remove(0);
			return true;
		} else {
			return false;
		}
	}

	private List<String> getMatchList(String key, String masterKey) {
		List<String> list = new ArrayList<String>();

		if (key.isEmpty()) {
			if (!masterKey.isEmpty()) {
				// prevent duplication of last letter
				masterKey = masterKey.substring(0,masterKey.length() - 1);
			}
			
			list = getTree(masterKey);
			return list;
		}
		
		String firstChar = getFirstCharString(key);

		for (int i = 0; i < tree.size(); ++i) {
			SuffixTree subTree = tree.get(i);
			if (firstChar.equalsIgnoreCase(subTree.match)) {
				String keyMinusFirstChar = getAfterFirstChar(key);
				list.addAll(subTree.getMatchList(keyMinusFirstChar, masterKey + firstChar));
			}
		}

		return list;
	}

	private List<String> getTree(String prefix) {
		List<String> list = new ArrayList<String>();

		if (tree.isEmpty()) {
			list.add(prefix);
		}

		for (int i = 0; i < tree.size(); ++i) {
			list.addAll(tree.get(i).getTree(prefix + match));
		}

		return list;
	}

	private SuffixTree(String string) {
		match = getFirstCharString(string).toLowerCase();

		if (string.isEmpty()) {
			tree = new ArrayList<SuffixTree>();
		} else {
			initializeTree(getAfterFirstChar(string));
		}
	}
	
	private String getAfterFirstChar(String string) {
		if (string.isEmpty()) {
			return EMPTY_STRING;
		}
		
		return string.substring(1);
	}
	
	private String getFirstCharString(String string) {
		if (string.isEmpty()) {
			return EMPTY_STRING;
		}
		
		return string.substring(0, 1);
	}

	private void initializeTree(String string) {
		SuffixTree subTree = new SuffixTree(string);
		tree = new ArrayList<SuffixTree>();
		tree.add(subTree);
	}

	private void insertAtEnd(String string) {
		SuffixTree newTree = new SuffixTree(string);
		tree.add(newTree);
	}

	private void insertBefore(String string, int index) {
		SuffixTree newTree = new SuffixTree(string);
		tree.add(index, newTree);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\SuffixTree.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\SuffixTreeTest.java
	 */


public class SuffixTreeTest {
	SuffixTree tree;
	List<String> list;
	List<String> expected;
	
	final String emptyString = "";

	@Before
	public void setUp() {
		tree = new SuffixTree();
		expected = new ArrayList<String>();
	}

	@Test
	public void noElementTest() {
		setUp();
		expected.add(emptyString);
		list = tree.getMatchList(emptyString);
		assertEquals("Test no added elements", expected, list);
	}

	@Test
	public void singleElementTest() {
		setUp();
		tree.add("A");
		expected.add("a");
		list = tree.getMatchList(emptyString);
		assertEquals("Single alpha character", expected, list);
		
		setUp();
		tree.add(emptyString);
		list = tree.getMatchList(emptyString);
		expected.add(emptyString);
		assertEquals("Add preexisting empty string", expected, list);
		
		setUp();
		tree.add("&");
		expected.add("&");
		list = tree.getMatchList(emptyString);
		assertEquals("Single nonalpha character", expected, list);
	}
	
	@Test
	public void singleLengthElementsTest() {
		setUp();
		tree.add("A");
		tree.add("a");
		tree.add("a");
		expected.add("a");
		list = tree.getMatchList(emptyString);
		assertEquals("Two of same alpha character", expected, list);
		
		setUp();
		tree.add("c");
		tree.add("%");
		tree.add("8");
		expected.add("%");
		expected.add("8");
		expected.add("c");
		list = tree.getMatchList(emptyString);
		assertEquals("Three different single-characters", expected, list);
	}
	
	@Test
	public void multipleLengthElementsTest() {
		setUp();
		tree.add("And");
		tree.add("a");
		tree.add("atr");
		expected.add("a");
		expected.add("and");
		expected.add("atr");
		list = tree.getMatchList(emptyString);
		assertEquals("words with same start letter", expected, list);
		
		setUp();
		tree.add("And");
		tree.add("a");
		tree.add("atr");
		tree.add("atr");
		expected.add("a");
		expected.add("and");
		expected.add("atr");
		list = tree.getMatchList(emptyString);
		assertEquals("duplicate word", expected, list);
		
		tree.add("break it up");
		tree.add("digger through all");
		tree.add("creation it is");
		expected.add("break it up");
		expected.add("creation it is");
		expected.add("digger through all");
		list = tree.getMatchList(emptyString);
		assertEquals("sentences", expected, list);
		
		// symbols used to be treated differently
		tree.add("%^&$(");
		tree.add("575");
		expected.add("%^&$(");
		expected.add("575");
		expected.sort(null);
		list = tree.getMatchList(emptyString);
		assertEquals("symbols", expected, list);
	}
	
	@Test
	public void shorterListTest() {
		setUp();
		tree.add("complete");
		tree.add("completed");
		tree.add("completes");
		tree.add("compliment");
		tree.add("complimented");
		
		expected.add("complete");
		expected.add("completed");
		expected.add("completes");
		expected.add("compliment");
		expected.add("complimented");
		list = tree.getMatchList("comp");
		assertEquals("request from middle of word", expected, list);
		
		expected.clear();
		expected.add("compliment");
		expected.add("complimented");
		list = tree.getMatchList("compliment");
		assertEquals("request noninclusive list from middle", expected, list);
		
		expected.clear();
		expected.add("complimented");
		list = tree.getMatchList("complimented");
		assertEquals("request the entirety of a unique word", expected, list);
		
		list = tree.getMatchList("testing");
		assertEquals("no matches", true, list.isEmpty());
	}
	
	@Test
	public void deleteTest() {
		setUp();
		tree.add("c");
		tree.add("%");
		tree.add("8");
		tree.remove("%");
		expected.add("8");
		expected.add("c");
		list = tree.getMatchList(emptyString);
		assertEquals("Delete single branch", expected, list);
		
		setUp();
		tree.add("And");
		tree.add("a");
		tree.add("atr");
		tree.remove("aND");
		expected.add("a");
		expected.add("atr");
		list = tree.getMatchList(emptyString);
		assertEquals("remove more complex word", expected, list);
		
		setUp();
		tree.add("And");
		tree.add("a");
		tree.add("atr");
		tree.remove("aNDD");
		expected.add("a");
		expected.add("and");
		expected.add("atr");
		list = tree.getMatchList(emptyString);
		assertEquals("remove a nonexistant word", expected, list);
		
		setUp();
		tree.add("And");
		tree.add("a");
		tree.add("atr");
		tree.remove("an");
		expected.add("a");
		expected.add("and");
		expected.add("atr");
		list = tree.getMatchList(emptyString);
		assertEquals("remove a word that was part of another", expected, list);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\SuffixTreeTest.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java
	 */

	public Task(Task other) {
		startdate = other.startdate;
		enddate = other.enddate;
		name = other.name;
		location = other.location;
		note = other.note;
		category = other.category;
		starttime = other.starttime;
		endtime = other.endtime;

		hasDeadline = other.hasDeadline;
		isComplete = other.isComplete;
		hasNote = other.hasNote;
		hasLocation = other.hasLocation;
		hasStartTime = other.hasStartTime;
		hasEndTime = other.hasEndTime;
		isOverdue = other.isOverdue;
		hasCategory = other.hasCategory;
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java
	 */

	public Task(String nm, String cat, String loc, String note, Date start, Date end, Time s, Time e) throws Exception {
		if (nm != null) {
			this.setName(nm);
		}
		if (cat != null) {
			this.setCategory(cat);
		}
		if (loc != null) {
			this.setLocation(loc);
		}
		if (note != null) {
			this.setNote(note);
		}
		if (start != null) {
			this.startdate = start;
		}
		if (end != null) {
			this.setEndDate(end);
		}
		if (s != null) {
			this.setStartTime(s);
		}
		if (e != null) {
			this.setEndTime(e);
		}

		setIfOverdue();
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java
	 */

	public void setEqualTo(Task other) {
		startdate = other.startdate;
		enddate = other.enddate;
		name = other.name;
		location = other.location;
		note = other.note;
		category = other.category;
		starttime = other.starttime;
		endtime = other.endtime;

		hasDeadline = other.hasDeadline;
		isComplete = other.isComplete;
		hasNote = other.hasNote;
		hasLocation = other.hasLocation;
		hasStartTime = other.hasStartTime;
		hasEndTime = other.hasEndTime;
		isOverdue = other.isOverdue;
		hasCategory = other.hasCategory;
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java
	 */

	private void setIfOverdue() throws Exception {
		if (!hasDeadline) {
			return;
		}

		Date today = new Date();
		if (enddate.isBefore(today)) {
			isOverdue = true;
			return;
		} 

		boolean isOnSameDay = today.isEquals(enddate);

		if (!isOnSameDay) {
			return;	// not before, so must be after
		}

		if (!hasEndTime) {
			return;
		}

		Time now = getNow();
		int equal = 0;
		if (endtime.compareTo(now) < equal) {
			isOverdue = true;
		}
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java
	 */

	public boolean hasCategory() {
		return hasCategory;
	}

	public void setStartTime(Time s) throws Exception {
		if(s == null) {
			setHasStartTime(false);
			return;
		}  

		setHasStartTime(true);
		starttime = s;

		if (!hasEndTime) {
			Time autoEndTime = new Time(s.getHours() + 1, s.getMins());
			this.setEndTime(autoEndTime);
		}
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java
	 */

	public String toString(){
		String answer = new String();
		answer = answer + "Task: " + this.name + NEW_LINE;
		if(hasCategory){
			answer = answer + "Category: " + this.category + NEW_LINE;
		} else {
			answer = answer + "Category: " + MESSAGE_NO_CATEGORY + NEW_LINE;
		}
		if(!hasDeadline){
			answer = answer + "Start: " + this.getStartDate().toString() + " @ " +
					this.getStartTime().toString() + NEW_LINE + "End: " + 
					MESSAGE_NO_END + NEW_LINE;
		} else {
			answer = answer + "Start: " + this.getStartDate().toString() + 
					" @ " + this.getStartTime().toString() + NEW_LINE + 
					"End: " + this.getEndDate().toString() + " @ " + 
					this.getEndTime().toString() + NEW_LINE;
		}
		if(hasLocation){
			answer = answer + "Location: " + this.getLocation() + NEW_LINE;
		} else {
			answer = answer + "Location: " + MESSAGE_NO_LOCATION + NEW_LINE;
		}
		if(hasNote){
			answer = answer + "Note: " + this.getNote() + NEW_LINE;
		} else {
			answer = answer + "Note: " + MESSAGE_NO_NOTE + NEW_LINE;
		}
		if(isComplete) {
			answer = answer + "Completed: Yes" + NEW_LINE;
		} else {
			answer = answer + "Completed: No" + NEW_LINE;
		}
		return answer;
	}

	public String toPrint(){
		String answer = new String();
		answer = answer + "Task: " + this.name + NEW_LINE;
		if(hasCategory){
			answer = answer + "Category: " + this.category + NEW_LINE;
		} 
		if(!hasDeadline){
			answer = answer + "Start: " + this.getStartDate().toPrint() + 
					" @ " + this.getStartTime().toString() + NEW_LINE + 
					"End: " + MESSAGE_NO_END + NEW_LINE;
		} else {
			answer = answer + "Start: " + this.getStartDate().toPrint() + 
					" @ " + this.getStartTime().toString() + NEW_LINE + "End: "
					+ this.getEndDate().toPrint() + " @ " + 
					this.getEndTime().toString() + NEW_LINE;
		} if(hasLocation){
			answer = answer + "Location: " + this.location + NEW_LINE;
		}
		if(hasNote){
			answer = answer + "Note: " + this.note + NEW_LINE;
		}
		if(isComplete) {
			answer = answer + "Completed: Yes" + NEW_LINE;
		} else {
			answer = answer + "Completed: No" + NEW_LINE;
		}
		return answer;
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\Task.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\TaskFileErrorException.java
	 */


import java.util.List;

@SuppressWarnings("serial")
public class TaskFileErrorException extends Exception {
	private List<String> errorList;
	private List<Task> taskList;
	
	public TaskFileErrorException(List<String> errList, List<Task>tkList) {
		super("Warning: Task file error. Skipping corrupt tasks and attempting"
				+ "\n to save corrupt lines to RecoveredTaskFile...");
		errorList = errList;
		taskList = tkList;
	}
	
	public List<String> getErrorList() {
		return errorList;
	}
	
	public List<Task> getTaskList() {
		return taskList;
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataEncapsulation\TaskFileErrorException.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Add.java
	 */

	private void updateAutocomplete() {
		Autocomplete autocomplete = Autocomplete.getInstance();
		autocomplete.addTitle(taskName);
		autocomplete.addCategory(taskCategory);
		autocomplete.addLocation(taskLocation);
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Add.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Add.java
	 */

	@Override
	protected void checkValidity() throws BadSubcommandException {
		super.checkValidity();
		checkForNoDuplicateSubcommands();
		checkDateMatches();
	}

	private void checkDateMatches() throws BadSubcommandException {
		boolean hasGeneralDate = hasSubcommandType(Subcommand.TYPE.DATE);
		boolean hasStartDate = hasSubcommandType(Subcommand.TYPE.START);
		boolean hasEndDate = hasSubcommandType(Subcommand.TYPE.END);

		if ((hasGeneralDate && hasStartDate) || (hasGeneralDate && hasEndDate)) {
			throw new BadSubcommandException("cannot specify start and/or end when specifying \"date\"");
		}
	}

	@Override
	public String undo() throws Exception {
		
		Remove negatedAddCommand = new Remove(subcommands);
		return negatedAddCommand.executeRemoveLiteral();
		
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Add.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\All.java
	 */


import java.util.List;

import userInterface.ezCMessages;
import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.NoResultException;
import dataEncapsulation.Task;
import dataManipulation.CommandType.COMMAND_TYPE;

public class All extends Command {

	public All(List<Subcommand> commandComponents)
			throws BadCommandException, BadSubcommandException {
		super(COMMAND_TYPE.ALL, commandComponents);
	}

	@Override
	public String execute() throws NoResultException {
		ezCMessages allTasksMessage = ezCMessages.getInstance();
		String displayAllTasks = allTasksMessage.getAllTasksListMessage();
		
		List<Task> allTasks = getAllUncompletedTasks();
		String stringTasks = getStringOfAllTasks(allTasks);
		
		displayAllTasks += stringTasks;
		return displayAllTasks;
	}

	private List<Task> getAllUncompletedTasks() {
		TotalTaskList totalList = TotalTaskList.getInstance();
		List<Task> tasks = totalList.getNotCompleted();
		
		return tasks;
	}

	private String getStringOfAllTasks(List<Task> list) throws NoResultException {
		ezCMessages messages = ezCMessages.getInstance();
		return messages.getStringOfTasks(list);
	}

	@Override
	public String undo() throws Exception {
		return null;
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\All.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\ChangeDateType.java
	 */


import java.util.List;

import userInterface.ezCMessages;
import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.Date;
import dataManipulation.CommandType.COMMAND_TYPE;
import fileIo.FileIo;

public class ChangeDateType extends Command {

	public String previousType;
	
	public ChangeDateType(List<Subcommand> commandComponents)
			throws BadCommandException, BadSubcommandException {
		super(COMMAND_TYPE.CHANGE_DATE_TYPE, commandComponents);
	}

	@Override
	public String execute() {
		previousType = Date.getFormat();
		String type = getDateType();
		changeDateFormat(type);
		
		ezCMessages messages = ezCMessages.getInstance();
		FileIo fileIo = FileIo.getInstance();
		fileIo.rewriteFile();
		
		return messages.getChangeDateTypeMessage(type);
	}
	
	@Override
	public String undo() throws Exception {
		if (previousType.equals("d/m")) {
			Date.changeFormatDm();
		} else {
			Date.changeFormatMd();
		}
		
		ezCMessages messages = ezCMessages.getInstance();
		FileIo fileIo = FileIo.getInstance();
		fileIo.rewriteFile();
		
		return messages.getChangeDateTypeMessage(previousType);
	}

	private String getDateType() {
		return subcommands.get(0).getContents();
	}

	private void changeDateFormat(String type) {
		if (type.equals("d/m")) {
			Date.changeFormatDm();
		} else {
			Date.changeFormatMd();
		}
	}

	@Override
	protected void checkValidity() throws BadSubcommandException {
		super.checkValidity();
		checkForNoDuplicateSubcommands();
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\ChangeDateType.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Command.java
	 */


public abstract class Command {
	protected COMMAND_TYPE type;
	protected List<Subcommand> subcommands;
	
	public abstract String execute() throws Exception;
	
	public abstract String undo() throws Exception;
	
	public Command(COMMAND_TYPE commandType, 
			List<Subcommand> commandComponents) 
					throws BadCommandException, BadSubcommandException {
		if (commandType == null || commandComponents == null) {
			throw new IllegalArgumentException("null argument for Command constructor");
		}
		
		type = commandType;
		subcommands = commandComponents;
		
		checkValidity();
	}
	
	public COMMAND_TYPE getType() {
		return type;
	}
	
	public List<Subcommand> getComponents() {
		return subcommands;
	}
	
	protected void checkValidity() throws BadSubcommandException {
		for (int i = 0; i < subcommands.size(); ++i) {
			Subcommand component = subcommands.get(i);
			CommandType checker = CommandType.getInstance();

			if (!checker.isSubcommand(type, component.getType())) {
				throw new BadSubcommandException("invalid subcommand");
			}
		}
	}
	
	protected boolean hasSubcommandType(Subcommand.TYPE type) {
		for (int j = 0; j < subcommands.size(); ++j) {
			Subcommand other = subcommands.get(j);
			if (type == other.getType()) {
				return true;
			}
		}
		
		return false;
	}

	protected void checkForNoComponents() throws BadSubcommandException {
		if (!subcommands.isEmpty()) {
			throw new BadSubcommandException("too many subcommands");
		}
	}
	
	protected void checkForNoDuplicateSubcommands() throws BadSubcommandException {
		if (subcommands.size() == 0) {
			return;
		}
		
		Subcommand current;
		Subcommand temp;
		
		for (int i = 0; i < subcommands.size() - 1; ++i) {
			current = subcommands.get(i);
			for (int j = i + 1; j < subcommands.size(); ++j) {
				temp = subcommands.get(j);
				if (current.getType() == temp.getType()) {
					throw new BadSubcommandException("duplicate subcommands");
				}
			}
		}
		
		return;
	}
	
	protected void checkForComponentAmount(int amount) throws BadSubcommandException {
		if (subcommands.size() > amount) {
			throw new BadSubcommandException("too many subcommands");
		} else if (subcommands.size() < amount) {
			throw new BadSubcommandException("not enough information");
		}
	}
	
	@Override
	public String toString() {
		String formattedType = "Command Type: " + type;
		String newLine = "\n";
		String fullMessage = new String(formattedType + newLine);
		
		for (int i = 0; i < subcommands.size(); ++i) {
			fullMessage = fullMessage + subcommands.get(i).toString() + newLine;
		}
		
		return fullMessage;
	}
	
	protected void parseDateToStartAndEnd() throws BadSubcommandException, BadSubcommandArgException {
		int index = 0;
		for (; index < subcommands.size(); ++index) {
			if (subcommands.get(index).getType() == Subcommand.TYPE.DATE) {
				break;
			}
		}

		Subcommand date = subcommands.get(index);
		String dateString = date.getContents();
		Subcommand start = new Subcommand(Subcommand.TYPE.START, dateString);
		Subcommand end = new Subcommand(Subcommand.TYPE.END, dateString);

		subcommands.remove(index);
		subcommands.add(start);
		subcommands.add(end);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Command.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\CommandType.java
	 */


import java.util.ArrayList;
import java.util.List;

import dataEncapsulation.BadCommandException;
import dataManipulation.Subcommand.TYPE;

public class CommandType {
	private static CommandType records;

	public enum COMMAND_TYPE {
		ADD, ALL, CHANGE_DATE_TYPE, COMPLETED, EDIT, FINISH, 
		HELP, OVERDUE, REDO, REMOVE, REPEAT, SEARCH, TODAY, UNFINISH,
		UNDO,
		INVALID;

		@Override
		public String toString() {
			if (name().equals("INVALID")) {
				String nothing = "";
				return nothing;
			} else if (name().contains("_")) {
				return name().replace("_", " ").toLowerCase();
			}
			
			return this.name().toLowerCase();
		}
	}

	private CommandType() {}

	public static CommandType getInstance() {
		if (records == null) {
			records = new CommandType();
		}
		return records;
	}

	public static COMMAND_TYPE determineCommandType(String commandTypeString) 
			throws BadCommandException {
		assert(commandTypeString != null);
		commandTypeString = commandTypeString.trim();
		String lowerCaseCommand = commandTypeString.toLowerCase();

		switch (lowerCaseCommand) {
		case "add" :
			return COMMAND_TYPE.ADD;
		case "all" :
			return COMMAND_TYPE.ALL;
		case "completed" :
			return COMMAND_TYPE.COMPLETED;
		case "delete" :
			return COMMAND_TYPE.REMOVE;
		case "edit" :
			return COMMAND_TYPE.EDIT;
		case "filter" :
			return COMMAND_TYPE.SEARCH;
		case "finish" :
			return COMMAND_TYPE.FINISH;
		case "help" :
			return COMMAND_TYPE.HELP;
		case "overdue" :
			return COMMAND_TYPE.OVERDUE;
		case "redo" :
			return COMMAND_TYPE.REDO;
		case "remove" :
			return COMMAND_TYPE.REMOVE;
		case "repeat" :
			return COMMAND_TYPE.REPEAT;
		case "search" :
			return COMMAND_TYPE.SEARCH;
		case "today" :
			return COMMAND_TYPE.TODAY;
		case "unfinish" :
			return COMMAND_TYPE.UNFINISH;
		case "undo" :
			return COMMAND_TYPE.UNDO;
		case "view" :
			return COMMAND_TYPE.SEARCH;
		default :
			throw new BadCommandException("unrecognized command type");
		}
	}

	public boolean isSubcommand(COMMAND_TYPE commandType, Subcommand.TYPE subcommandType) {
		switch (commandType) {
		case ADD :
			return isAddType(subcommandType);
		case CHANGE_DATE_TYPE :
			return isChangeDateTypeType(subcommandType);
		case EDIT :
			return isEditType(subcommandType);
		case FINISH :
			return isFinishType(subcommandType);
		case HELP :
			return isHelpType(subcommandType);
		case REMOVE :
			return isRemoveType(subcommandType);
		case REPEAT :
			return isRepeatType(subcommandType);
		case SEARCH :
			return isSearchType(subcommandType);
		case UNFINISH :
			return isUnfinishType(subcommandType);
		default :
			return false;
		}
	}

	/**
	 * This method returns the name of all subcommand types
	 * as they are visible to the user. That is, instead of returning
	 * Subcommand.TYPE.FREQUENCY, it will return a list of the strings
	 * once, weekly, monthly, yearly, and so on.
	 * @param commandType
	 * @return
	 */
	public List<String> getSubcommands(COMMAND_TYPE commandType) {
		switch (commandType) {
		case ADD :
			return getAddSubcommands();
		case CHANGE_DATE_TYPE :
			return getChangeDateTypeSubcommands();
		case HELP :
			return getHelpSubcommands();
		case EDIT :
			return getEditSubcommands();
		case FINISH :
			return getFinishSubcommands();
		case REMOVE :
			return getRemoveSubcommands();
		case REPEAT :
			return getRepeatSubcommands();
		case SEARCH :
			return getSearchSubcommands();
		default :
			return new ArrayList<String>();
		}
	}

	private List<String> getAddSubcommands() {
		List<String> list = new ArrayList<String>();
		list.add(Subcommand.TYPE.DATE.toString());
		list.add(Subcommand.TYPE.CATEGORY.toString());
		list.add(Subcommand.TYPE.END.toString());
		list.add(Subcommand.TYPE.LOCATION.toString());
		list.add(Subcommand.TYPE.NOTE.toString());
		list.add(Subcommand.TYPE.START.toString());
		list.add(Subcommand.TYPE.STARTTIME.toString());
		list.add(Subcommand.TYPE.ENDTIME.toString());
		
		return list;
	}

	private List<String> getChangeDateTypeSubcommands() {
		List<String> list = new ArrayList<String>();
		for (Subcommand.DATE_TYPE type : Subcommand.DATE_TYPE.values()) {
			list.add(type.toString());
		}
		
		return list;
	}

	private List<String> getEditSubcommands() {
		List<String> list = getAddSubcommands();
		list.add(Subcommand.TYPE.TITLE.toString());
		
		return list;
	}

	private List<String> getFinishSubcommands() {
		return getAddSubcommands();
	}
	
	private List<String> getHelpSubcommands() {
		List<String> list = new ArrayList<String>();
		
		for (Subcommand.HELP_KEY type : Subcommand.HELP_KEY.values()) {
			list.add(type.toString());
		}
		
		return list;
	}

	private List<String> getRemoveSubcommands() {
		return getAddSubcommands();
	}

	private List<String> getRepeatSubcommands() {
		List<String> list = new ArrayList<String>();
		
		for (Subcommand.FREQUENCY type : Subcommand.FREQUENCY.values()) {
			list.add(type.toString());
		}
		
		list.add(Subcommand.TYPE.NAME.toString());
		list.add(Subcommand.TYPE.START.toString());
		list.add(Subcommand.TYPE.END.toString());
		
		return list;
	}

	private List<String> getSearchSubcommands() {
		List<String> list = getEditSubcommands();
		list.add(Subcommand.TYPE.AND.toString());
		list.add(Subcommand.TYPE.OR.toString());
		list.add(Subcommand.TYPE.COMPLETED.toString());
		list.add(Subcommand.TYPE.FREE.toString());
		
		return list;
	}

	private boolean isAddType(TYPE subcommandType) {
		switch (subcommandType) {
			case NAME :
				return true;
			case CATEGORY :
				return true;
			case DATE :
				return true;
			case END :
				return true;
			case LOCATION :
				return true;
			case NOTE :
				return true;
			case ON:
				return true;
			case START :
				return true;
			case STARTTIME :
				return true;
			case TITLE :
				return true;
			case ENDTIME :
				return true;
			default :
				return false;
		}
	}

	private boolean isChangeDateTypeType(TYPE subcommandType) {
		switch (subcommandType) {
		case DATE_TYPE :
			return true;
		default :
			return false;
		}
	}

	private boolean isEditType(TYPE subcommandType) {
		boolean isEditType = isAddType(subcommandType);
		switch (subcommandType) {
		case TITLE :
			return true;
		default :
			return isEditType;
		}
	}

	private boolean isFinishType(TYPE subcommandType) {
		return isAddType(subcommandType);
	}

	private boolean isRemoveType(TYPE subcommandType) {
		return isAddType(subcommandType);
	}

	private boolean isRepeatType(TYPE subcommandType) {
		switch (subcommandType) {
			case FREQUENCY :	 // valid
				return true;
			case NAME :
				return true;
			case START :
				return true;
			case END :
				return true;
			default :
				return false;
		}
	}

	private boolean isSearchType(TYPE subcommandType) {
		boolean isSearchType = isEditType(subcommandType);
		switch (subcommandType) {
			case AND :
				return true;
			case COMPLETED :
				return true;
			case FREE :
				return true;
			case OR :
				return true;
			case TEXT:
				return true;
			default :
				return isSearchType;
		}
	}

	private boolean isUnfinishType(TYPE subcommandType) {
		return isAddType(subcommandType);
	}
	
	private boolean isHelpType(TYPE subcommandType) {
		switch (subcommandType) {
		case HELP :
			return true;
		case DATE :
			return true;
		case COMPLETED :
			return true;
		default :
			return false;
		}
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\CommandType.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Completed.java
	 */


import java.util.List;

import userInterface.ezCMessages;
import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.NoResultException;
import dataEncapsulation.Task;
import dataManipulation.CommandType.COMMAND_TYPE;

public class Completed extends Command {

	public Completed(List<Subcommand> commandComponents)
			throws BadCommandException, BadSubcommandException {
		super(COMMAND_TYPE.COMPLETED, commandComponents);
	}

	@Override
	public String execute() throws NoResultException {
		List<Task> allTasks = getAllCompletedTasks();
		String stringTasks = getStringOfAllTasks(allTasks);
		
		ezCMessages completedTasksMessage = ezCMessages.getInstance();
		String displayCompletedTasks = completedTasksMessage.getCompletedTasksListMessage();
		displayCompletedTasks += stringTasks;
		
		return displayCompletedTasks;
	}

	private List<Task> getAllCompletedTasks() {
		TotalTaskList totalList = TotalTaskList.getInstance();
		return totalList.getCompleted();
	}

	private String getStringOfAllTasks(List<Task> list) throws NoResultException {
		ezCMessages messages = ezCMessages.getInstance();
		return messages.getStringOfTasks(list);
	}

	@Override
	protected void checkValidity() throws BadSubcommandException {
		super.checkValidity();
		checkForNoDuplicateSubcommands();
	}

	@Override
	public String undo() throws Exception {
		return null;
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Completed.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java
	 */

	@Override
	public String execute() throws Exception {
		try {
			if (trueTask == null) {
				trueTask = getTaskToEdit();
			}
	
			return executeMainEdit();
		} catch (BadSubcommandArgException repeatException) {
			if (posteditCopy != null) {
				throw new BadSubcommandArgException("Another task matches the "
						+ "changes you want to go back to");
			} else {
				throw new BadSubcommandArgException("Another task matches the "
						+ "changes you want to make");
			}
		}
	}
	
	public Task getTask() {
		return trueTask;
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java
	 */

	public String furtherEdit(Task toEdit) throws Exception {

		trueTask = toEdit;
		
		try {
			String result = executeMainEdit();
			return result;
		} catch (BadSubcommandArgException repeatException) {
			if (posteditCopy != null) {
				throw new BadSubcommandArgException("Another task matches the "
						+ "changes you want to go back to");
			} else {
				throw new BadSubcommandArgException("Another task matches the "
						+ "changes you want to make");
			}
		}
	}
	
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java
	 */

	private String executeMainEdit() throws Exception {
		if (preeditCopy == null) {
			preeditCopy = new Task(trueTask);
		}
		Task temp = new Task(trueTask);
		setTaskAttributes(temp, subcommands);

		addEditedTask(temp, trueTask);
		
		if (posteditCopy == null) {
			posteditCopy = new Task(trueTask);
		}

		updateAutocomplete();
		FileIo.getInstance().rewriteFile();
		String editComplete = messages.getEditMessage(preeditCopy, trueTask);
		return editComplete;
	}


	private void updateAutocomplete() {
		Autocomplete autocomplete = Autocomplete.getInstance();
		autocomplete.addCategory(trueTask.getCategory());
		autocomplete.addTitle(trueTask.getName());
		autocomplete.addLocation(trueTask.getLocation());
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java
	 */

	private void addEditedTask(Task copy, Task toEditAndAdd) throws Exception {
		boolean isRepeat = ExactMatchSearcher.isTaskDuplicate(copy);
		
		if (isRepeat) {
			throw new BadSubcommandArgException("Task you want to create already exists");
		}
		
		toEditAndAdd.setEqualTo(copy);
		taskList.update();
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java
	 */

	@Override
	public String undo() throws Exception {
		if (preeditCopy == null) {
			return "cannot undo because original edit was not successful";
		}
		
		trueTask.setEqualTo(preeditCopy);
		FileIo.getInstance().rewriteFile();
		taskList.update();
        
		ezCMessages messages = ezCMessages.getInstance();
        String returnMessage = messages.getUndoEditMessage(posteditCopy, trueTask);
		return returnMessage;

	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Edit.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Finish.java
	 */


import java.util.List;

import powerSearch.ExactMatchSearcher;
import userInterface.ezCMessages;
import dataEncapsulation.ActionException;
import dataEncapsulation.ActionException.ErrorLocation;
import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.NoResultException;
import dataEncapsulation.Task;
import dataManipulation.CommandType.COMMAND_TYPE;
import fileIo.FileIo;

public class Finish extends Command {

	public Finish(List<Subcommand> commandComponents) 
			throws BadCommandException, BadSubcommandException, 
			BadSubcommandArgException {
		super(COMMAND_TYPE.FINISH, commandComponents);
		boolean hasDateSubcommand = hasSubcommandType(Subcommand.TYPE.DATE);
		if (hasDateSubcommand) {
			parseDateToStartAndEnd();
		}
	}
	
	@Override
	public String undo() throws Exception {
		Unfinish reverse = new Unfinish(subcommands);
		return reverse.literalUnfinish();
	}

	@Override
	public String execute() throws Exception {
		Task markedTask = markAsCompleted();
		ezCMessages messages = ezCMessages.getInstance();
		String stringTask = messages.getFinishMessage(markedTask);
		FileIo IoStream = FileIo.getInstance();
		IoStream.rewriteFile();
		return stringTask;
	}
	
	public Task markAsCompleted() throws Exception {
		TotalTaskList masterList = TotalTaskList.getInstance();
		List<Task> taskToBeMarked = ExactMatchSearcher.literalSearch(subcommands, masterList.getNotCompleted());
		if (taskToBeMarked.size() > 1) {
			throw new ActionException(taskToBeMarked, ErrorLocation.FINISH, subcommands);
		} else if (taskToBeMarked.size() == 0) {
			throw new Exception("no match found");
		}
		Task toComplete = taskToBeMarked.get(0);
		finishTask(toComplete);
		
		return toComplete;
	}
	
	private void finishTask(Task toComplete) throws Exception {
		TotalTaskList masterList = TotalTaskList.getInstance();
		List<Task> toSearchThrough = masterList.getNotCompleted();
		boolean wasSuccess = toSearchThrough.remove(toComplete);
		if (!wasSuccess) {
			toSearchThrough = masterList.getOverdue();
			wasSuccess = toSearchThrough.remove(toComplete);
			if (!wasSuccess) {
				throw new Exception("no match found");
			}
		}
		
		toComplete.setComplete();
		masterList.addCompleted(toComplete);
	}

	public void addEditedTask(Task oldTask, Task newTask) {
		TotalTaskList list = TotalTaskList.getInstance();
		FileIo IoStream = FileIo.getInstance();
		
		list.removeNotCompleted(oldTask);
		list.addCompleted(newTask);
		IoStream.rewriteFile();
	}
	

	@Override
	protected void checkValidity() throws BadSubcommandException {
		super.checkValidity();
		checkForNoDuplicateSubcommands();
	}

	public String literalFinish() throws BadCommandException, 
		BadSubcommandException, BadSubcommandArgException, Exception {
		TotalTaskList list = TotalTaskList.getInstance();
		List<Task> completed = list.getCompleted();
		Task perfectMatch = findLiteralMatch(subcommands, completed);

		ezCMessages messages = ezCMessages.getInstance();
		return messages.getFinishMessage(perfectMatch);
	}
	
	private Task findLiteralMatch(List<Subcommand> subcommands, List<Task> list) 
			throws BadCommandException, 
			BadSubcommandException, BadSubcommandArgException, Exception {

		Task match = (new Add(subcommands)).buildTask(subcommands);
		TotalTaskList totalList = TotalTaskList.getInstance();
		List<Task> currentTasks = totalList.getList();

		for (int i = 0; i < currentTasks.size(); ++i) {
			Task current = currentTasks.get(i);
			if (current.isEqualTask(match)) {
				current.setComplete();
				currentTasks.remove(current);
				totalList.addCompleted(current);
				return current;
			}
		}
		
		currentTasks = TotalTaskList.getInstance().getOverdue();
		for (int i = 0; i < currentTasks.size(); ++i) {
			Task current = currentTasks.get(i);
			if (current.isEqualTask(match)) {
				current.setComplete();
				currentTasks.remove(current);
				totalList.addCompleted(current);
				return current;
			}
		}
		
		throw new NoResultException("The task that you are trying to finish cannot be found.");
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Finish.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiCommand.java
	 */


import java.util.ArrayList;
import java.util.List;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.Task;
import dataManipulation.CommandType.COMMAND_TYPE;

public abstract class MultiCommand<T extends Command> extends Command {

	protected List<T> commands = new ArrayList<T>();
	
	public MultiCommand(List<Task> choices) throws BadCommandException,
			BadSubcommandException, BadSubcommandArgException {
		super(COMMAND_TYPE.INVALID, new ArrayList<Subcommand>());
		initializeCommands(choices);
	}

	private void initializeCommands(List<Task> choices) throws 
	BadSubcommandException, BadSubcommandArgException, BadCommandException {
		for (Task t : choices) {
			List<Subcommand> choiceSubcommands = 
				Add.dismantleTask(t);
			T newCommand = makeCommand(choiceSubcommands);
			commands.add(newCommand);
		}
	}
	
	abstract T makeCommand(List<Subcommand> choices) 
			throws BadCommandException, BadSubcommandException, 
			BadSubcommandArgException;
	
	abstract String specializedExecute(T command) throws Exception;

	@Override
	public String execute() throws Exception {
		String message = "";
		for (T command : commands) {
			String toReport = specializedExecute(command);
			message = appendReport(message, toReport);
		}
		return message;
	}

	@Override
	public String undo() throws Exception {
		String message = "";
		for (T command : commands) {
			String toReport = command.undo();
			message = appendReport(message, toReport);
		}
		return message;
	}

	private String appendReport(String ret, String toReport) {
		if (!ret.isEmpty()) {
			ret = ret + "\n";
		}
		ret = ret + toReport;
		return ret;
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiCommand.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiEditor.java
	 */


import java.util.ArrayList;
import java.util.List;

import userInterface.ezCMessages;
import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.Task;
import dataManipulation.CommandType.COMMAND_TYPE;

public class MultiEditor extends Command {

	private List<Edit> editors = new ArrayList<Edit>();
	private List<Edit> successfulEdits = new ArrayList<Edit>();
	private List<Task> tasksToEdit = new ArrayList<Task>();
	
	public MultiEditor(List<Task> choices, List<Subcommand> changes) throws BadCommandException,
			BadSubcommandException, BadSubcommandArgException {
		super(COMMAND_TYPE.EDIT, changes);	// check only edit-type subcommands
		tasksToEdit = choices;
		initializeEditors(choices);
		super.type = COMMAND_TYPE.INVALID;	// should not be recognized as a user-command
	}

	private void initializeEditors(List<Task> choices) throws 
	BadSubcommandException, BadSubcommandArgException, BadCommandException {
		for (int i = 0; i < choices.size(); ++i) {
			Edit editor = new Edit(subcommands);
			editors.add(editor);
		}
	}

	@Override
	public String execute() throws Exception {
		successfulEdits.clear();
		
		String message = new String();
		List<Task> failedToEdit = new ArrayList<Task>();
		ezCMessages messages = ezCMessages.getInstance();
		String failureMessage = new String();
		
		for (int i = 0; i < editors.size(); ++i) {
			Edit editor = editors.get(i);
			Task toEdit = tasksToEdit.get(i);
			try {
				editor.furtherEdit(toEdit);
				Task justEdited = editor.getTask();
				message = appendReport(message, 
						messages.makePrintableTask(justEdited) + "\n");
				successfulEdits.add(editor);
			} catch (Exception e) {
				failedToEdit.add(toEdit);
				failureMessage = e.getMessage();
			}
		}
		
		if (!failedToEdit.isEmpty()) {
			String failureHeader = "Could not edit each of the following because " + failureMessage.toLowerCase();
			String failedTasks = messages.getStringOfTasks(failedToEdit);
			String toAppend = failureHeader + "\n\n" + failedTasks;
			message = appendReport(message, toAppend);
		}
		
		return message;
	}

	@Override
	public String undo() throws Exception {
		String message = "Successfully unedited:";
		ezCMessages messages = ezCMessages.getInstance();
		
		for (Edit editor : successfulEdits) {
			editor.undo();
			Task justEdited = editor.getTask();
			String toReport = messages.makePrintableTask(justEdited);
			message = appendReport(message, "\n" + toReport);
		}
		return message;
	}

	private String appendReport(String ret, String toReport) {
		if (!ret.isEmpty()) {
			ret = ret + "\n";
		}
		ret = ret + toReport;
		return ret;
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiEditor.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiFinish.java
	 */


import java.util.List;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.Task;

public class MultiFinish extends MultiCommand<Finish> {

	public MultiFinish(List<Task> choices) throws BadCommandException,
			BadSubcommandException, BadSubcommandArgException {
		super(choices);
	}

	@Override
	Finish makeCommand(List<Subcommand> choices) throws BadCommandException,
			BadSubcommandException, BadSubcommandArgException {
		return new Finish(choices);
	}

	@Override
	String specializedExecute(Finish command) throws Exception {
		return command.literalFinish();
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiFinish.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiRemove.java
	 */


import java.util.List;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.Task;

public class MultiRemove extends MultiCommand<Remove> {
	
	public MultiRemove(List<Task> choices) throws BadCommandException,
			BadSubcommandException, BadSubcommandArgException {
		super(choices);
	}

	@Override
	public String execute() throws Exception {
		String message = "";
		for (Remove remove : commands) {
			String toReport = remove.executeRemoveLiteral();
			message = appendReport(message, toReport);
		}
		return message;
	}

	@Override
	public String undo() throws Exception {
		String message = "";
		for (Remove remove : commands) {
			String toReport = remove.undo();
			message = appendReport(message, toReport);
		}
		return message;
	}

	private String appendReport(String ret, String toReport) {
		if (!ret.isEmpty()) {
			ret = ret + "\n";
		}
		ret = ret + toReport;
		return ret;
	}

	@Override
	Remove makeCommand(List<Subcommand> choices) 
			throws BadCommandException, BadSubcommandException, BadSubcommandArgException {
		return new Remove(choices);
	}

	@Override
	String specializedExecute(Remove command) throws Exception {
		return command.executeRemoveLiteral();
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiRemove.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiUnfinish.java
	 */


import java.util.List;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.Task;

public class MultiUnfinish extends MultiCommand<Unfinish> {

	public MultiUnfinish(List<Task> choices) throws BadCommandException,
			BadSubcommandException, BadSubcommandArgException {
		super(choices);
	}

	@Override
	Unfinish makeCommand(List<Subcommand> choices) throws BadCommandException,
			BadSubcommandException, BadSubcommandArgException {
		return new Unfinish(choices);
	}

	@Override
	String specializedExecute(Unfinish command) throws Exception {
		return command.literalUnfinish();
	}


}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\MultiUnfinish.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Overdue.java
	 */


import java.util.List;

import userInterface.ezCMessages;
import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.NoResultException;
import dataEncapsulation.Task;
import dataManipulation.CommandType.COMMAND_TYPE;

public class Overdue extends Command{
	public Overdue(List<Subcommand> commandComponents)
			throws BadCommandException, BadSubcommandException {
		super(COMMAND_TYPE.OVERDUE, commandComponents);
	}

	@Override
	public String execute() throws Exception {
		TotalTaskList totalList = TotalTaskList.getInstance();
		totalList.update();
		List<Task> overdueTasks = totalList.getOverdue();
		
		ezCMessages overdueTasksMessage = ezCMessages.getInstance();
		String displayOverdueTasks = overdueTasksMessage.getOverdueTasksListMessage();
		displayOverdueTasks += getStringOfAllTasks(overdueTasks);
		
		return displayOverdueTasks;
	}

	private String getStringOfAllTasks(List<Task> list) throws NoResultException {
		ezCMessages messages = ezCMessages.getInstance();
		return messages.getStringOfTasks(list);
	}

	@Override
	public String undo() throws Exception {
		return null;
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Overdue.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Remove.java
	 */

	public String executeRemoveLiteral() throws Exception {
		int indexOfDeletionList = initializeTasksFound(subcommands);
		List<Task> listToDeleteFrom = getDeletionList(indexOfDeletionList);
		Task perfectMatch = findLiteralMatch(subcommands, listToDeleteFrom);
		taskRemoved = doDeleteTask(perfectMatch, indexOfDeletionList);
		updateFile();
		ezCMessages messages = ezCMessages.getInstance();
		return messages.getDeleteMessage(taskRemoved);
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Remove.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Search.java
	 */

	private Date getDateForFree() throws Exception {
		assert(subcommands.size() == 2);
		int firstIndex = 0;
		int secondIndex = firstIndex + 1;
		
		String dateString;
		
		if (subcommands.get(firstIndex).getType() == Subcommand.TYPE.DATE) {
			dateString = subcommands.get(0).getContents();
		} else if (subcommands.get(secondIndex).getType() == Subcommand.TYPE.DATE) {
			dateString = subcommands.get(secondIndex).getContents();
		} else {
			throw new BadSubcommandException("missing date component");
		}
		
		Date realDate = (new Date()).determineDate(dateString);
		return realDate;
	}

	@Override
	public String undo() throws Exception {
		return null;
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Search.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Subcommand.java
	 */


public class Subcommand {
	public enum TYPE {
		AND, BYEND, BYNAME, BYSTART, CATEGORY, COMPLETED, DATE, DATE_TYPE, END,
		ENDTIME, FREE, HELP, LOCATION, NAME, NONE, NOTE, FREQUENCY, ON, OR, PAREN, START, 
		STARTTIME, TEXT, TITLE,
		INVALID;
		
		@Override
		public String toString() {
			if (name().equals(INVALID.name())) {
				String nothing = "";
				return nothing;
			} else if (name().equals(ENDTIME.name())) {
				return "to";
			} else if (name().equals(STARTTIME.name())) {
				return "from";
			}
			
			return name().toLowerCase();
		}
	}
	
	// All possibilities for the frequency keyword
	public enum FREQUENCY {
		DAILY, WEEKLY, MONTHLY, ANNUALLY, ONCE;
		
		@Override
		public String toString() {
			return this.name().toLowerCase();
		}
	}
	
	// All keywords for the help type
	public enum HELP_KEY {
		ADD, ALL, EDIT, FINISH, LIST, REDO, REMOVE, REPEAT, SEARCH, TODAY, UNDO, UNFINISH,
		DATE, TIME, COMPLETE, COMPLETED;
		
		@Override
		public String toString() {
			return this.name().toString().toLowerCase();
		}
	}
	
	public enum PAREN {
		OPEN_PAREN, CLOSE_PAREN;
		
		@Override
		public String toString() {
			if (this.name().equals("OPEN_PAREN")) {
				return "(";
			} else {
				return ")";
			}
		}
	}
	
	public enum WEEKDAYS {
		TOMORROW, TODAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, 
		SATURDAY, SUNDAY;
		
		@Override
		public String toString() {
			return this.name().toString().toLowerCase();
		}
	}
	
	// The two possibilities (plus invalid) for the date display/read type
	public enum DATE_TYPE {
		DAY_MONTH, MONTH_DAY;
		
		@Override
		public String toString() {
			switch(this) {
				case DAY_MONTH :
					return "d/m";
				case MONTH_DAY :
					return "m/d";
				default :
					return this.name().toLowerCase();
			}
		}
	}
	
	private TYPE type;
	private String contents;
	
	public Subcommand(TYPE componentType, 
			String componentContents) throws BadSubcommandException, BadSubcommandArgException {
		type = componentType;
		contents = componentContents;
		
		checkValidity();
	}

	public TYPE getType() {
		return type;
	}
	
	public String getContents() {
		return contents;
	}
	
	private void checkValidity() throws BadSubcommandException, BadSubcommandArgException {
		if (type == TYPE.INVALID) {
			throw new BadSubcommandException("invalid subcommand type");
		}
		
		switch (type) {
			case FREQUENCY :
				checkFrequencyContents();
				break;
			case DATE_TYPE :
				checkDateTypeContents();
				break;
			case PAREN :
				checkParenContents();
				break;
			case HELP :
				checkHelpKeyContents();
				break;
			default :
				break;	// no restrictions on contents
		}
		
		return;
	}
	
	private void checkHelpKeyContents() throws BadSubcommandArgException {
		boolean isValid = false;
		
		if (contents.equals(HELP_KEY.ADD.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.ALL.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.EDIT.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.FINISH.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.DATE.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.LIST.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.COMPLETE.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.COMPLETED.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.REDO.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.REMOVE.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.REPEAT.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.SEARCH.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.TIME.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.TODAY.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.UNDO.toString())) {
			isValid = true;
		} else if (contents.equals(HELP_KEY.UNFINISH.toString())) {
			isValid = true;
		}
		
		if (!isValid) {
			throw new BadSubcommandArgException("There is no help feature for the command you have input.");
		}
	}

	private void checkParenContents() throws BadSubcommandArgException {
		boolean isValid = false;
		
		if (contents.equals(PAREN.OPEN_PAREN.toString())) {
			isValid = true;
		} else if (contents.equals(PAREN.CLOSE_PAREN.toString())) {
			isValid = true;
		}
		
		if (!isValid) {
			throw new BadSubcommandArgException("invalid paren specified");
		}
	}

	private void checkFrequencyContents() throws BadSubcommandArgException {
		boolean isValid = false;
		
		if (contents.equals(FREQUENCY.DAILY.toString())) {
			isValid = true;
		} else if (contents.equals(FREQUENCY.WEEKLY.toString())) {
			isValid = true;
		} else if (contents.equals(FREQUENCY.MONTHLY.toString())) {
			isValid = true;
		} else if (contents.equals(FREQUENCY.ANNUALLY.toString())) {
			isValid = true;
		} else if (contents.equals(FREQUENCY.ONCE.toString())) {
			isValid = true;
		}
		
		if (!isValid) {
			throw new BadSubcommandArgException("invalid frequency specified");
		}
	}
	
	private void checkDateTypeContents() throws BadSubcommandArgException {
		boolean isValid = false;
		
		if (contents.equals(DATE_TYPE.DAY_MONTH.toString())) {
			isValid = true;
		} else if (contents.equals(DATE_TYPE.MONTH_DAY.toString())) {
			isValid = true;
		}
		
		if (!isValid) {
			throw new BadSubcommandArgException("invalid date format specified");
		}
	}
	
	@Override
	public String toString() {
		String formattedType = "Component Type: " + type;
		String newLine = "\n";
		String formattedContents = "Contents: " + contents;
		
		String total = formattedType + newLine + formattedContents;
		return total;
	}
	
	public static Subcommand.TYPE determineComponentType(
			String componentTypeString) {
		componentTypeString = componentTypeString.trim();
		
		switch (componentTypeString.toLowerCase()) {
		case ("(") :
			return TYPE.PAREN;
		case (")") :
			return TYPE.PAREN;
		case ("by name") :
			return TYPE.BYNAME;
		case ("by end") :
			return TYPE.BYEND;
		case ("by start") :
			return TYPE.BYSTART;
		case ("and") :
			return TYPE.AND;
		case ("&") :
			return TYPE.AND;
		case ("add") :
			return TYPE.HELP;
		case ("all") :
			return TYPE.HELP;
		case ("annually") :
			return TYPE.FREQUENCY;
		case ("begin") :
			return TYPE.START;
		case ("category") :
			return TYPE.CATEGORY;
		case ("cat") :
			return TYPE.CATEGORY;
		case ("completed") :
			return TYPE.COMPLETED;
		case ("complete") :
			return TYPE.COMPLETED;
		case ("daily") :
			return TYPE.FREQUENCY;
		case ("date") :
			return TYPE.DATE;
		case ("deadline") :
			return TYPE.END;
		case ("edit") :
			return TYPE.HELP;
		case ("end") :
			return TYPE.END;
		case ("finish") :
			return TYPE.HELP;
		case ("free") :
			return TYPE.FREE;
		case ("from") : 
			return TYPE.STARTTIME;
		case ("list") :
			return TYPE.HELP;
		case ("location") :
			return TYPE.LOCATION;
		case ("monthly") :
			return TYPE.FREQUENCY;
		case ("note") :
			return TYPE.NOTE;
		case ("on") : 
			return TYPE.ON;
		case ("or") :
			return TYPE.OR;
		case ("once") :
			return TYPE.FREQUENCY;
		case ("redo") :
			return TYPE.HELP;
		case ("remove") :
			return TYPE.HELP;
		case ("repeat") :
			return TYPE.HELP;
		case ("search") :
			return TYPE.HELP;
		case ("start") :
			return TYPE.START;
		case ("time") :
			return TYPE.HELP;
		case ("title") :
			return TYPE.TITLE;
		case ("to") : 
			return TYPE.ENDTIME;
		case ("today") :
			return TYPE.HELP;
		case ("undo") :
			return TYPE.HELP;
		case ("unfinish") :
			return TYPE.HELP;
		case ("weekly") :
			return TYPE.FREQUENCY;
		default :
			return TYPE.INVALID;
		}
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Subcommand.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Unfinish.java
	 */


import java.util.List;

import powerSearch.ExactMatchSearcher;
import userInterface.ezCMessages;
import dataEncapsulation.ActionException;
import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.NoResultException;
import dataEncapsulation.Task;
import dataEncapsulation.ActionException.ErrorLocation;
import dataManipulation.CommandType.COMMAND_TYPE;
import fileIo.FileIo;

public class Unfinish extends Command {

	public Unfinish(List<Subcommand> commandComponents) 
			throws BadCommandException, BadSubcommandException, 
			BadSubcommandArgException {
		super(COMMAND_TYPE.UNFINISH, commandComponents);
		boolean hasDateSubcommand = hasSubcommandType(Subcommand.TYPE.DATE);
		if (hasDateSubcommand) {
			parseDateToStartAndEnd();
		}
	}

	@Override
	public String undo() throws Exception {
		Finish reverse = new Finish(subcommands);
		return reverse.literalFinish();
	}

	@Override
	public String execute() throws Exception {
		Task markedTask = markAsNotCompleted();
		ezCMessages messages = ezCMessages.getInstance();
		String stringTask = messages.getUnfinishMessage(markedTask);
		rewriteFile();
		return stringTask;
	}

	private void rewriteFile() {
		FileIo IoStream = FileIo.getInstance();
		IoStream.rewriteFile();
	}

	private Task markAsNotCompleted() throws Exception {
		TotalTaskList masterList = TotalTaskList.getInstance();
		List<Task> taskToBeMarked = ExactMatchSearcher.literalSearch(subcommands, masterList.getCompleted());
		if (taskToBeMarked.size() > 1) {
			throw new ActionException(taskToBeMarked, ErrorLocation.UNFINISH, subcommands);
		} else if (taskToBeMarked.size() == 0) {
			throw new Exception("no match found");
		}
		Task toUncomplete = taskToBeMarked.get(0);
		unfinishTask(toUncomplete);

		return toUncomplete;
	}

	private void unfinishTask(Task toUncomplete) throws Exception {
		TotalTaskList masterList = TotalTaskList.getInstance();
		List<Task> toSearchThrough = masterList.getCompleted();
		boolean wasSuccess = toSearchThrough.remove(toUncomplete);
		if (!wasSuccess) {
			throw new Exception("no match found");
		}

		toUncomplete.setIncomplete();
		if (toUncomplete.isOverdue()) {
			masterList.addOverdue(toUncomplete);
		} else {
			masterList.addNotCompleted(toUncomplete);
		}
	}


	@Override
	protected void checkValidity() throws BadSubcommandException {
		super.checkValidity();
		checkForNoDuplicateSubcommands();
	}

	public String literalUnfinish() throws BadCommandException, 
	BadSubcommandException, BadSubcommandArgException, Exception {
		TotalTaskList list = TotalTaskList.getInstance();
		List<Task> completed = list.getCompleted();
		Task perfectMatch = findLiteralMatch(subcommands, completed);

		completed.remove(perfectMatch);
		perfectMatch.setIncomplete();
		list.addNotCompleted(perfectMatch);
		list.update();

		ezCMessages messages = ezCMessages.getInstance();
		return messages.getUnfinishMessage(perfectMatch);
	}

	private Task findLiteralMatch(List<Subcommand> subcommands, List<Task> list) 
			throws BadCommandException, 
			BadSubcommandException, BadSubcommandArgException, Exception {

		Task match = (new Add(subcommands)).buildTask(subcommands);
		TotalTaskList totalList = TotalTaskList.getInstance();
		List<Task> currentTasks = totalList.getCompleted();

		for (int i = 0; i < currentTasks.size(); ++i) {
			Task current = currentTasks.get(i);
			if (current.isEqualTask(match)) {
				return current;
			}
		}

		throw new NoResultException("The task that you are trying to finish cannot be found.");
	}


}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\dataManipulation\Unfinish.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\fileIo\FileIo.java
	 */


import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataEncapsulation.Date;
import dataEncapsulation.Task;
import dataEncapsulation.TaskFileErrorException;
import dataManipulation.TotalTaskList;

/*
 * This class acts as the interface between the File IO component
 * and the Main and Data Manipulation components. The other
 * classes within the file IO package can be accessed through here.
 * 
 * Its usefulness is that we don't have to deal with the components
 * of the entire class and can neatly see the methods we care about.
 */

public class FileIo {
	private final String fileName = "ezCTasks.txt";
	private TextIoStream fileStream;
	private TotalTaskList list = TotalTaskList.getInstance();
	private TaskFileReader reader = TaskFileReader.getInstance();
	private final String dateType = "Middle Endian Format";
	private static final String NEW_LINE = System.getProperty("line.separator");

	private static FileIo fileIo;

	public FileIo() {
		try {
			fileStream = new TextIoStream(fileName);
		} catch (IOException e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
	}

	public static FileIo getInstance() {
		if (fileIo == null) {
			fileIo = new FileIo();
		}

		return fileIo;
	}

	// Takes the lines of text from the task file and creates tasks from them.
	public List<Task> getAllTasks(List<String> linesOfText) throws Exception {
		List<Task> taskList = reader.getAllTasks(linesOfText);
		return taskList;
	}

	// Takes the lines of text from the task file and creates tasks from them.
	public void rewriteFile() {
		try {
			List<String> empty = new ArrayList<String>();
			fileStream.rewriteFile(empty);
			if (!Date.isFormatDm()) {
				String total = dateType + NEW_LINE;
				fileStream.appendFile(total);
			}
			fileStream.appendFile(list.getAllTasks());
			return;
		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} catch (IOException e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
	}

	/*
	 * Returns the contents from the task file as a list of strings with each
	 * index in the list corresponding to the matching line in the file.
	 * If there is an error, it returns null.
	 */
	public List<String> readFromFile() throws FileNotFoundException, IOException {
		List<String> lines;
		lines = fileStream.readFromFile();
		return lines;
	}

	public void initializeTaskList(TotalTaskList taskList) throws Exception {
		List<String> fileContents;
		TaskFileErrorException badFile = null;

		fileContents = fileStream.readFromFile();
		
		changeDateTypeIfSpecified(fileContents);
		
		Date today = new Date();
		List<Task> tasksFromFile;
		try {
			tasksFromFile = reader.getAllTasks(fileContents);
		} catch (TaskFileErrorException e) {
			tasksFromFile = e.getTaskList();
			badFile = e;
		}
		for(Task t : tasksFromFile) {
			if(t.getIsComplete() == false && !(t.getEndDate().isBefore(today))) {
				taskList.addNotCompleted(t);
			}
			else if(t.getIsComplete() == true) {
				taskList.addCompleted(t);
			}
			else if(t.getIsComplete() == false && t.getEndDate().isBefore(today)) {
				taskList.addOverdue(t);
			}
		}

		if (badFile != null) {
			throw badFile;
		}

		return;
	}

	private void changeDateTypeIfSpecified(List<String> fileContents)
			throws BadSubcommandException, BadSubcommandArgException,
			BadCommandException {
		if (fileContents.get(0).equalsIgnoreCase(dateType)) {
			Date.changeFormatMd();
			fileContents.remove(0);
		}
	}

	public void recover(TaskFileErrorException e) throws FileNotFoundException, IOException {
		DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
		Date day = new Date();
		Calendar cal = Calendar.getInstance();
		fileStream.rewriteFile(e.getTaskList());
		TextIoStream errorFileStream = 
				new TextIoStream("RecoveredTaskFile.txt");
		errorFileStream.appendFile("\nDate of error detection: " + day + " @ "
				+ dateFormat.format(cal.getTime()) + "\n");
		errorFileStream.appendFile(e.getErrorList());
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\fileIo\FileIo.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\fileIo\TaskFileReader.java
	 */


import java.util.ArrayList;
import java.util.List;

import userInterface.Autocomplete;
import dataEncapsulation.Date;
import dataEncapsulation.Task;
import dataEncapsulation.TaskFileErrorException;
import dataEncapsulation.Time;

/**
 * This class reads the file contents from the ezC task storage file.
 * It does not anticipate incorrect formatting and will throw an exception when
 * it encounters a bad file line.
 * 
 * Note: It would be better to report to the user which task is incorrectly
 * formatted, and then to just skip that task and let the user deal with it
 * himself. Perhaps give the option of deleting the task or replacing the task
 * with a valid one. (dump the invalid lines on the screen for the user to see.
 * After dumping, once more give the option of just deleting the garbage if it
 * is unusable to the user)
 *
 */

public class TaskFileReader {
	private static TaskFileReader tfr;
	
	private TaskFileReader() {}
	
	public static TaskFileReader getInstance() {
		if (tfr == null) {
			tfr = new TaskFileReader();
		}
		
		return tfr;
	}
	
	// integers are indexes for their corresponding location in the task 
	// component list
	public enum TASK_COMPONENT {
		NAME(0), CATEGORY(1), START(2), END(3), LOCATION(4), NOTE(5), 
		COMPLETED(6), START_TIME(7), END_TIME(8);
		private int value;
		
		private TASK_COMPONENT(int val) {
			value = val;
		}
		
		public int getIndex() {
			return value;
		}
	}
	
	private final String LINE_TITLE_DELIMITER = ":";
	private final String EMPTY_STRING = "";
	
	private final String MESSAGE_NO_END = Task.MESSAGE_NO_END;
	private final String MESSAGE_NO_LOCATION = Task.MESSAGE_NO_LOCATION;
	private final String MESSAGE_NO_NOTE = Task.MESSAGE_NO_NOTE;
	private final String MESSAGE_COMPLETED = Task.MESSAGE_COMPLETED;
	private final String MESSAGE_NO_CATEGORY = Task.MESSAGE_NO_CATEGORY;
	
	private final int FIRST_POSITION = 0;
	private final String TIME_DELIMITER = "@";
	
	private boolean hasNewInfo = false;

	private List<String> taskComponents = new ArrayList<String>();

	public List<Task> getAllTasks(List<String> componentsFromFile) throws TaskFileErrorException {
		List<Task> taskList = new ArrayList<Task>();
		List<String> errorList = new ArrayList<String>();
		List<String> possibleError = new ArrayList<String>();
		clearTaskComponents();
		
		for (int i = 0; i < componentsFromFile.size(); ++i) {
			String currentLine = componentsFromFile.get(i);
			
			if (currentLine.equals(EMPTY_STRING) && hasNewInfo) {
				try {
					Task newTask = createTask();
					if (newTask != null) {
						taskList.add(newTask);
						possibleError.clear();
					}
				} catch (Exception e) {
					possibleError.add("\n");
					errorList.addAll(possibleError);
					possibleError.clear();
				}
				clearTaskComponents();
			} else if (!currentLine.equals(EMPTY_STRING)){
				try {	
					possibleError.add(currentLine);
					addComponent(currentLine);
				} catch (Exception e) {
					clearTaskComponents();
					errorList.addAll(possibleError);
					possibleError.clear();
				}
				
			}
		}
		
		if (!errorList.isEmpty()) {
			throw new TaskFileErrorException(errorList, taskList);
		}
		
		return taskList;
	}

	private Task createTask() throws Exception {
		checkForMissingComponents();
		
		String name = getName();
		String category = getCategory();
		String location = getLocation();
		String note = getNote();
		String startDateString = getStartDateString();
		String endDateString = getEndDateString();
		String completed = getCompleted();
		String startTimeString = getStartTimeString();
		String endTimeString = getEndTimeString();
		
		Date start = (new Date()).determineDate(startDateString);
		Date end = (new Date()).determineDate(endDateString);
		
		Time startTime = (new Time()).determineTime(startTimeString);
		Time endTime = (new Time()).determineTime(endTimeString);
		
		Task newTask = new Task(name, category, location, note, start, end, startTime, endTime);
		addToAutocomplete(name, category, location);
		
		if (completed.equalsIgnoreCase(MESSAGE_COMPLETED)) {
			newTask.setComplete();
		}
		
		return newTask;
	}

	private void addToAutocomplete(String name,
			String category, String location) {
		Autocomplete autocomplete = Autocomplete.getInstance();
		
		if (category != null) {
			autocomplete.addCategory(category);
		}
		if (location != null) {
			autocomplete.addLocation(location);
		}
		if (name != null) {
			autocomplete.addTitle(name);
		}
	}

	// sets missing components to null, as expected by TaskFactory
	private void checkForMissingComponents() throws Exception {
		if (isAnyElementNull()) {
			throw new Exception("Data missing from task");
		}
		
		String location = getLocation();
		String note = getNote();
		String end = getEndDateString();
		String category = getCategory();
		
		if (end.equals(MESSAGE_NO_END)) {
			taskComponents.set(TASK_COMPONENT.END.getIndex(), null);
		}
		
		if (location.equals(MESSAGE_NO_LOCATION)) {
			taskComponents.set(TASK_COMPONENT.LOCATION.getIndex(), null);
		}
		
		if (note.equals(MESSAGE_NO_NOTE)) {
			taskComponents.set(TASK_COMPONENT.NOTE.getIndex(), null);
		}
		
		if (category.equals(MESSAGE_NO_CATEGORY)) {
			taskComponents.set(TASK_COMPONENT.CATEGORY.getIndex(), null);
		}
		
		return;
		
	}

	private boolean isAnyElementNull() {
		String name = getName();
		String category = getCategory();
		String location = getLocation();
		String note = getNote();
		String startDateString = getStartDateString();
		String endDateString = getEndDateString();
		String completed = getCompleted();
		
		if (name == null || category == null || location == null ||
				note == null || startDateString == null || 
				endDateString == null || completed == null) {
			return true;
		}
		
		return false;
	}

	// adds the component from the line to the list of task components, in its
	// designated location
	private void addComponent(String currentLine) {
		TASK_COMPONENT component = determineComponentType(currentLine);
		int index = component.getIndex();
		String componentData = getComponentData(currentLine);
		
		if (component == TASK_COMPONENT.START || 
				component == TASK_COMPONENT.END) {
			componentData = getDateData(currentLine);
			taskComponents.set(index, componentData);
			
			component = getTimeCounterpart(component);
			index = component.getIndex();
			componentData = getTimeData(currentLine);
		}
			
		taskComponents.set(index, componentData);
		
		hasNewInfo = true;
		
		return;
	}

	private TASK_COMPONENT getTimeCounterpart(TASK_COMPONENT component) {
		if (component == TASK_COMPONENT.START) {
			return TASK_COMPONENT.START_TIME;
		} else if (component == TASK_COMPONENT.END) {
			return TASK_COMPONENT.END_TIME;
		} else {
			return component;
		}
	}

	private String getDateData(String currentLine) {
		currentLine = getComponentData(currentLine);
		String[] split = currentLine.split(TIME_DELIMITER);
		String date = split[0];
		date = date.trim();
		
		return date;
	}

	private String getTimeData(String currentLine) {
		if (!currentLine.contains(TIME_DELIMITER)) {
			return null;
		}
		
		String[] split = currentLine.split(TIME_DELIMITER);
		String time = split[1];
		time = time.trim();
		return time;
	}

	// made public for testing purposes. May have use outside of this class
	public TASK_COMPONENT determineComponentType(String string) {
		String lineTitle = getFirstWord(string);
		TASK_COMPONENT lineType = interpretTitle(lineTitle);
		return lineType;
	}
	
	// made public for testing purposes. May have use outside of this class
	public String getComponentData(String currentLine) {
		String lineTitle = getFirstWord(currentLine) + LINE_TITLE_DELIMITER;
		
		String lineData = 
				currentLine.replaceFirst(lineTitle, EMPTY_STRING);
		
		String noWhitespaceData = lineData.trim();
		
		return noWhitespaceData;
	}

	// made public for testing purposes. May have use outside of this class
	public String getFirstWord(String string) {
		String[] stringDividedAtFirstWord = string.split(LINE_TITLE_DELIMITER);
		
		String lineTitle = stringDividedAtFirstWord[FIRST_POSITION];
		
		return lineTitle;
	}
	
	// made public for testing purposes. May have use outside of this class
	public TASK_COMPONENT interpretTitle(String lineTitle) {
		if (lineTitle.equalsIgnoreCase("task")) {
			return TASK_COMPONENT.NAME;
		} else if (lineTitle.equalsIgnoreCase("category")) {
			return TASK_COMPONENT.CATEGORY;
		} else if (lineTitle.equalsIgnoreCase("start")) {
			return TASK_COMPONENT.START;
		} else if (lineTitle.equalsIgnoreCase("end")) {
			return TASK_COMPONENT.END;
		} else if (lineTitle.equalsIgnoreCase("location")) {
			return TASK_COMPONENT.LOCATION;
		} else if (lineTitle.equalsIgnoreCase("note")) {
			return TASK_COMPONENT.NOTE;
		} else if (lineTitle.equalsIgnoreCase("completed")) {
			return TASK_COMPONENT.COMPLETED;
		} else {
			throw new RuntimeException("Invalid task in file");
		}
	}

	@SuppressWarnings("unused")
	// resets the task component list to have a space for each component
	private void clearTaskComponents() {
		taskComponents.clear();
		
		for (TASK_COMPONENT i : TASK_COMPONENT.values()) {
			taskComponents.add(null);
		}
		
		hasNewInfo = false;
		
		return;
	}
	
	private String getName() {
		return taskComponents.get(TASK_COMPONENT.NAME.getIndex());
	}
	
	private String getCategory() {
		return taskComponents.get(TASK_COMPONENT.CATEGORY.getIndex());
	}
	
	private String getLocation() {
		return taskComponents.get(TASK_COMPONENT.LOCATION.getIndex());
	}
	
	private String getNote() {
		return taskComponents.get(TASK_COMPONENT.NOTE.getIndex());
	}
	
	private String getStartDateString() {
		return taskComponents.get(TASK_COMPONENT.START.getIndex());
	}
	
	private String getEndDateString() {
		return taskComponents.get(TASK_COMPONENT.END.getIndex());
	}
	
	private String getCompleted() {
		return taskComponents.get(TASK_COMPONENT.COMPLETED.getIndex());
	}
	
	private String getStartTimeString() {
		return taskComponents.get(TASK_COMPONENT.START_TIME.getIndex());
	}
	
	private String getEndTimeString() {
		return taskComponents.get(TASK_COMPONENT.END_TIME.getIndex());
	}

}
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\fileIo\TaskFileReader.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\powerSearch\Searcher.java
	 */

	private static String getTimeString(int hour, int min) {
		String hourString = String.valueOf(hour);
		String minuteString = String.valueOf(min);
		
		if (min < 10) {
			minuteString = "0" + minuteString;
		}
		
		return hourString + ":" + minuteString;
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\powerSearch\Searcher.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ActionToggler.java
	 */


import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.JTextField;
import javax.swing.KeyStroke;

public class ActionToggler {
	private JTextField textField;
	
	private String actionKey;
	private String label;
	
	private AbstractAction masterAction;
	private AbstractAction lesserAction;
	
	private boolean hasLesser = false;
	private boolean hasMaster = false;
	
	public ActionToggler() {}
	
	public ActionToggler(JTextField field, String key, String lab, 
			AbstractAction action) {
		textField = field;
		actionKey = key;
		label = lab;
		masterAction = action;
		
		hasMaster = true;
	}
	
	public void initializeLesser(AbstractAction action) {
		lesserAction = action;
		hasLesser = true;
	}
	
	public void initializeMaster(JTextField field, String key, String lab, 
			AbstractAction action) {
		textField = field;
		actionKey = key;
		label = lab;
		masterAction = action;
		
		hasMaster = true;
	}
	
	public void setMaster() {
		if (!hasMaster) {
			return;
		}
		
		InputMap im = textField.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
		ActionMap am = textField.getActionMap();
		im.put(KeyStroke.getKeyStroke(actionKey), label);
		am.put(label, masterAction);
	}
	
	public void setLesser() {
		if (!hasLesser) {
			return;
		}
		
		InputMap im = textField.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
		ActionMap am = textField.getActionMap();
		im.put(KeyStroke.getKeyStroke(actionKey), label);
		am.put(label, lesserAction);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ActionToggler.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\Autocomplete.java
	 */


import java.util.ArrayList;
import java.util.List;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.SuffixTree;
import dataManipulation.CommandType;
import dataManipulation.CommandType.COMMAND_TYPE;
import dataManipulation.Subcommand;
import dataManipulation.Subcommand.TYPE;

public class Autocomplete {
	private SuffixTree commands = new SuffixTree();
	private List<SuffixTree> subcommands = new ArrayList<SuffixTree>();
	private SuffixTree titles = new SuffixTree();
	private SuffixTree categories = new SuffixTree();
	private SuffixTree locations = new SuffixTree();
	private SuffixTree days = new SuffixTree();
	
	private static Autocomplete autoComp;
	
	public static Autocomplete getInstance() {
		if (autoComp == null) {
			autoComp = new Autocomplete();
		}
		
		return autoComp;
	}
	
	public void addTitle(String newTitle) {
		titles.add(newTitle);
	}
	
	public void addCategory(String newCat) {
		categories.add(newCat);
	}
	
	public void addLocation(String newLoc) {
		locations.add(newLoc);
	}
	
	public void removeTitle(String oldTitle) {
		titles.remove(oldTitle);
	}
	
	public void removeCategory(String oldCategory) {
		categories.remove(oldCategory);
	}
	
	public void removeLocation(String oldLocation) {
		locations.remove(oldLocation);
	}
	
	public List<String> complete(String toComplete) {
		if (!hasCommand(toComplete)) {
			return getMatch(commands, toComplete);
		} if (isAwaitingArg(toComplete)) {
			 return getSubcommandArgMatches(toComplete);
		}
		
		return getSubcommandMatches(toComplete);
	}

	private List<String> getSubcommandArgMatches(String toComplete) {
		String quote = getLastQuote(toComplete);
		String lastWordRemoved = removeLastWord(toComplete, quote);
		Subcommand.TYPE subcommandType = getSubcommandType(lastWordRemoved);
		
		if (subcommandType == Subcommand.TYPE.INVALID) {
			if (isAwaitingDateKeyword(toComplete)) {
				subcommandType = Subcommand.TYPE.DATE;
				quote = getLastWord(toComplete);
				lastWordRemoved = removeLastWord(toComplete, quote) + " ";
			}
		}
		
		SuffixTree tree = getSubcommandArgTree(subcommandType);
		
		List<String> lastWordReplacements = getMatch(tree, quote);
		
		boolean needsQuotes = true;
		
		if (tree.equals(days)) {
			needsQuotes = false;
		}
		List<String> formattedOutput = formatArgOutput(lastWordReplacements, 
				lastWordRemoved, needsQuotes);
		
		return formattedOutput;
	}

	private String removeLastWord(String toComplete, String quote) {
		String lastWordRemoved = toComplete;
		boolean quoteNotStarted = quote.isEmpty() && !toComplete.endsWith("\"");
		boolean quoteWasStarted = !quoteNotStarted;
		if (quoteWasStarted) {
			lastWordRemoved = removeLastMatch("\"" + quote, toComplete);
		}
		return lastWordRemoved;
	}

	private List<String> formatArgOutput(List<String> lastWordReplacements,
			String lastWordRemoved, boolean needsQuotes) {
		List<String> formattedTotal = new ArrayList<String>();
		String quote = "\"";
		if (!needsQuotes) {
			quote = "";
		}
		
		for (int i = 0; i < lastWordReplacements.size(); ++i) {
			String suffix = lastWordReplacements.get(i);
			String formattedString;
			
			if (suffix.isEmpty()) {
				formattedString = lastWordRemoved;
			} else {
				formattedString = lastWordRemoved + quote + suffix + quote;
			}

			formattedTotal.add(formattedString);
		}
		
		return formattedTotal;
	}

	private TYPE getSubcommandType(String sentence) {
		Subcommand.TYPE type = getLastWordSubcommandType(sentence);
		
		// HELP matches the names of command types, so word is either "Help" 
		// or a command key work
		if (type == Subcommand.TYPE.HELP) {
			String lastWord = getLastWord(sentence.trim());
			type = checkForNameType(lastWord, sentence);
		}
		
		return type;
	}

	private Subcommand.TYPE checkForNameType(String lastWord, 
			String sentence) {
		String nothing = "";
		String withoutLast = sentence.replaceFirst(lastWord, nothing);
		String firstWord = getFirstWord(sentence);
		withoutLast = withoutLast.trim();
		
		if (withoutLast.equals(firstWord) && !withoutLast.isEmpty()) {
			return Subcommand.TYPE.HELP;
		}
		
		if (!withoutLast.isEmpty()) {
			return Subcommand.TYPE.HELP;
		}
		
		COMMAND_TYPE commandType = getCommandType(sentence);
		if (isNameType(commandType)) {
			return Subcommand.TYPE.NAME;
		} else {
			return Subcommand.TYPE.HELP;
		}
	}

	private boolean isNameType(COMMAND_TYPE commandType) {
		switch (commandType) {
		case ADD :
			return true;
		case EDIT :
			return true;
		case FINISH :
			return true;
		case REMOVE :
			return true;
		case REPEAT :
			return true;
		default :
			return false;	// no match
		}
	}

	private SuffixTree getSubcommandArgTree(TYPE subcommandType) {
		switch (subcommandType) {
			case NAME :
				return titles;
			case TITLE :
				return titles;
			case LOCATION :
				return locations;
			case CATEGORY :
				return categories;
			case DATE :
				return days;
			case START :
				return days;
			case END :
				return days;
			default :
				return new SuffixTree();	// no match
		}
	}

	private String getLastQuote(String sentence) {
		String quote = "\"";
		
		boolean hasStartedQuote = checkHasStartedQuote(sentence);
		if (sentence.endsWith(quote) || !hasStartedQuote) {
			String nothing = "";
			return nothing;
		}
		
		String[] split = sentence.split(quote);
		int lastIndex = split.length - 1;
		return split[lastIndex];
	}

	private boolean checkHasStartedQuote(String sentence) {
		int numberQuotes = getNumberOfOccurrences("\"", sentence);
		if (isEven(numberQuotes)) {
			return false;
		} else {
			return true;	// one unmatched quote
		}
	}

	private boolean isAwaitingArg(String toComplete) {
		int numberQuotes = getNumberOfOccurrences("\"", toComplete);
		if (isEven(numberQuotes)) {
			boolean isLastWordASubcommand = isLastWordSubcommand(toComplete);	// all started quotes end
			if (!isLastWordASubcommand) {
				return false;
			} else {
				return doesLastSubcommandNeedArg(toComplete) || isAwaitingDateKeyword(toComplete);
			}
		} else {
			return true;	// one unmatched quote
		}
	}

	private boolean doesLastSubcommandNeedArg(String sentence) {
		Subcommand.TYPE type = getLastWordSubcommandType(sentence);
		switch (type) {
			case COMPLETED :
				return false;
			case FREE :
				return false;
			case FREQUENCY :
				return false;
			case AND :
				return false;
			case OR :
				return false;
			default :
				return true;
		}
	}

	private Subcommand.TYPE getLastWordSubcommandType(String sentence) {
		sentence = sentence.trim();
		String lastWord = getLastWord(sentence);
		Subcommand.TYPE type = Subcommand.determineComponentType(lastWord);
		return type;
	}

	private boolean isLastWordSubcommand(String sentence) {
		String trimmedSentence = sentence.trim();
		String lastWord = getLastWord(trimmedSentence);
		Subcommand.TYPE type = Subcommand.determineComponentType(lastWord);
		if (type != Subcommand.TYPE.INVALID && type != Subcommand.TYPE.HELP) {
			return true;
		} else if (checkForNameType(lastWord, trimmedSentence) == Subcommand.TYPE.NAME) {
			return true;
		} else if (isAwaitingDateKeyword(sentence)) {
			return true;
		} else {
			return false;
		}
	}

	private boolean isAwaitingDateKeyword(String sentence) {
		String lastWord = getLastWord(sentence);
		String withoutLastWord = removeLastMatch(lastWord, sentence).trim();
		String secondToLastWord = getLastWord(withoutLastWord);
		return isDate(secondToLastWord);
	}
	
	private boolean isDate(String maybeDate) {
		switch (maybeDate.toLowerCase()) {
			case "date" :
				return true;
			case "start" :
				return true;
			case "end" :
				return true;
			default :
				return false;
		}
	}

	private boolean isEven(int number) {
		if (number%2 == 0) {
			return true;
		} else {
			return false;
		}
	}

	private int getNumberOfOccurrences(String splitter, String sentence) {
		int count = 0;
		
		if (sentence.endsWith(splitter)) {
			++count;
		}
		
		if (sentence.startsWith(splitter)) {
			++count;
		}
		
		String[] split = sentence.split(splitter);
		
		count = count + split.length - 1;
		
		return count;
	}

	private List<String> getSubcommandMatches(String toComplete) {
		COMMAND_TYPE commandType = getCommandType(toComplete);
		SuffixTree tree = getSubcommandTree(commandType);
		String lastWord = getLastWord(toComplete);
		List<String> lastWordReplacements = getMatch(tree, lastWord);
		String lastWordRemoved = removeLastMatch(lastWord, toComplete);
		List<String> formattedOutput = formatOutput(lastWordReplacements, 
				lastWordRemoved);
		
		return formattedOutput;
	}

	private COMMAND_TYPE getCommandType(String toComplete) {
		if (toComplete.trim().startsWith(COMMAND_TYPE.CHANGE_DATE_TYPE.toString())) {
			return COMMAND_TYPE.CHANGE_DATE_TYPE;
		}
		
		String commandString = getFirstWord(toComplete);
		
		try {
			return CommandType.determineCommandType(commandString);
		} catch (BadCommandException e) {
			return COMMAND_TYPE.INVALID;
		}
	}

	private String getFirstWord(String sentence) {
		String space = " ";
		String[] splitString = sentence.split(space);
		
		return splitString[0];
	}

	private SuffixTree getSubcommandTree(COMMAND_TYPE commandType) {
		int index = 0;
		
		for (COMMAND_TYPE type : COMMAND_TYPE.values()) {
			if (commandType.equals(type)) {
				return subcommands.get(index);
			}
			
			++index;
		}
		
		return new SuffixTree();
	}

	private String getLastWord(String sentence) {
		String space = " ";
		
		if (sentence.endsWith(space)) {
			return "";	// no last word
		}
		
		String[] splitString = sentence.split(space);
		int lastIndex = splitString.length - 1;
		
		return splitString[lastIndex];
	}

	private String removeLastMatch(String lastWord, String toTruncate) {
		int removedSize = lastWord.length();
		int lastIndex = toTruncate.length() - removedSize;
		return toTruncate.substring(0, lastIndex);
	}

	private List<String> formatOutput(List<String> lastWordReplacements, 
			String toComplete) {
		List<String> formattedTotal = new ArrayList<String>();
		
		for (int i = 0; i < lastWordReplacements.size(); ++i) {
			String suffix = lastWordReplacements.get(i);
			String formattedString = toComplete + suffix;
			formattedTotal.add(formattedString);
		}
		
		return formattedTotal;
	}

	private List<String> getMatch(SuffixTree findFrom, String toComplete) {
		List<String> matches = findFrom.getMatchList(toComplete);
		if (matches.isEmpty()) {
			matches.add(toComplete);
		}
		
		return matches;
	}

	private boolean hasCommand(String toComplete) {
		String space = " ";
		
		if (toComplete.contains(space)) {
			return true;
		} else {
			return false;
		}
	}
	
	private Autocomplete() {
		initializeCommands();
		initializeSubcommands();
		initializeDays();
	}
	
	private void initializeDays() {
		for (Subcommand.WEEKDAYS day : Subcommand.WEEKDAYS.values()) {
			days.add(day.toString());
		}
	}

	private void initializeSubcommands() {
		CommandType records = CommandType.getInstance();
		
		int index = 0;
		
		for (COMMAND_TYPE type : COMMAND_TYPE.values()) {
			List<String> list = records.getSubcommands(type);
			SuffixTree tree = subcommands.get(index);
			
			for (int i = 0; i < list.size(); ++i) {
				tree.add(list.get(i));
			}
			
			++index;
		}
	}

	private void initializeCommands() {
		for (COMMAND_TYPE type : COMMAND_TYPE.values()) {
			commands.add(type.toString());
			subcommands.add(new SuffixTree());
		}
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\Autocomplete.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\AutocompleteAction.java
	 */


import java.awt.event.ActionEvent;
import java.util.List;

import javax.swing.AbstractAction;
import javax.swing.JLabel;
import javax.swing.JTextField;

@SuppressWarnings("serial")
class AutocompleteAction extends AbstractAction {	
	final static String EXIT_ACTION = "exit-entry";
	
	private JTextField entry;
	private JLabel status;
	
	private String lastText;
	private Autocomplete autocomplete = Autocomplete.getInstance();

	private int counter = 0;
	private List<String> completionList;
	
	public AutocompleteAction(JLabel stat, JTextField ent) {
		entry = ent;
		status = stat;
		
		lastText = entry.getText();
		completionList = autocomplete.complete(lastText);
		counter = 0;
	}

	public void actionPerformed(ActionEvent ev) {
		status.setText(" ");
		String current = removeLeadingSpace(entry.getText());
		if (current.equalsIgnoreCase(lastText)) {
			entry.setText(completionList.get(counter));
			incrementCounter();
			lastText = entry.getText();
		} else {
			counter = 0;
			lastText = entry.getText();
			completionList = autocomplete.complete(lastText);
			entry.setText(completionList.get(counter));
			lastText = entry.getText();
			incrementCounter();
		}
	}

	private String removeLeadingSpace(String text) {
		String whitespace = "\\s+";
		if (text.startsWith(" ")) {
			return text.replaceFirst(whitespace, "");
		} else {
			return text;
		}
	}

	private void incrementCounter() {
		if (counter >= completionList.size() - 1) {
			counter = 0;
		} else {
			++counter;
		}
	}

}
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\AutocompleteAction.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\AutocompleteTest.java
	 */


import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import org.junit.Test;

import dataManipulation.CommandType;
import dataManipulation.CommandType.COMMAND_TYPE;

public class AutocompleteTest {
	Autocomplete autocomplete;
	List<String> key;
	
	@Before
	public void setUp() {
		autocomplete = Autocomplete.getInstance();
		key = new ArrayList<String>();
	}
	
	@Test
	public void getCommandTest() {
		for (COMMAND_TYPE type : COMMAND_TYPE.values()) {
			key.add(type.toString());
		}
		
		key.sort(null);
		
		String command = "";
		assertEquals("No given command", key, autocomplete.complete(command));
		
		key.clear();
		key.add("add");
		key.add("all");
		command = "a";
		assertEquals("beginning of a command", key, autocomplete.complete(command));
		
		key.clear();
		command = "bak";
		key.add("bak");
		assertEquals("beginning of an incommand", key, autocomplete.complete(command));
	}
	
	@Test
	public void getSubcommandTest() {
		key.clear();
		CommandType records = CommandType.getInstance();
		List<String> list = records.getSubcommands(COMMAND_TYPE.SEARCH);
			
		for (int i = 0; i < list.size(); ++i) {
			key.add("search " + list.get(i));
		}
		key.sort(null);
		
		String command = "search ";
		assertEquals("all search subcommands", key, autocomplete.complete(command));

		key.clear();
		key.add("search location");
		command = "search l";
		assertEquals("one add subcommands", key, autocomplete.complete(command));
	}
	
	@Test
	public void getSubcommandArgTest() {
		key.clear();
		autocomplete.addCategory("my cat");
		autocomplete.addCategory("my dog");
		autocomplete.addCategory("their cat");
		key.add("add \"new task\" category \"my cat\"");
		key.add("add \"new task\" category \"my dog\"");
		
		String command = "add \"new task\" category \"m";
		assertEquals("complete a category request with first quote", key, autocomplete.complete(command));
		
		// with first quote and without treated differently
		key.add("add \"new task\" category \"their cat\"");
		command = "add \"new task\" category ";
		assertEquals("complete a category request without first quote", key, autocomplete.complete(command));
		
		key.clear();
		autocomplete.addTitle("Go shopping");
		autocomplete.addTitle("Study for quiz");
		autocomplete.addTitle("Study for exam");
		key.add("add \"study for quiz\"");
		key.add("add \"study for exam\"");
		command = "add \"s";
		key.sort(null);
		assertEquals("complete a category request without first quote", key, autocomplete.complete(command));
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\AutocompleteTest.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\CommandHandlingAction.java
	 */


import java.awt.event.ActionEvent;

import javax.swing.AbstractAction;
import javax.swing.JLabel;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import dataEncapsulation.ActionException;
import dataEncapsulation.NoResultException;
import dataManipulation.Command;
import dataManipulation.UndoRedoList;

@SuppressWarnings("serial")
public class CommandHandlingAction extends AbstractAction {
	private CommandInterpreter interpreter = CommandInterpreter.getInstance();
	
	private JLabel status;
	private JTextArea display;
	private JTextField userInput;
	
	private ActionToggler enterToggle;
	private ExceptionHandler exceptionHandler;
	
	public CommandHandlingAction(JLabel stat, JTextArea disp, JTextField usrIn, ActionToggler toggle) {
		status = stat;
		display = disp;
		userInput = usrIn;
		enterToggle = toggle;
		exceptionHandler = new ExceptionHandler(usrIn, stat, disp, enterToggle);
	}
	
	public void actionPerformed(ActionEvent ev)  {
		try {
			status.setText(" ");
			String input = userInput.getText();
			Command command = interpreter.formCommand(input);
			String feedback = command.execute();
			userInput.setText("");
			
			UndoRedoList.getInstance().pushUndoCommand(command);
			
			setDisplayText(feedback);
		} catch (ActionException e) {
			userInput.setText("");
			exceptionHandler.furtherAction(e);
		} catch (NoResultException e) {
			String message = ezCMessages.getInstance().getErrorMessage(e);
			status.setText(message);
			userInput.setText("");
		} catch (Exception e) {
			String message = ezCMessages.getInstance().getErrorMessage(e);
			status.setText(message);
		}
	}
	
	private void setDisplayText(String message) {
		display.setText(message);
		
		int top = 0;
		display.setCaretPosition(top);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\CommandHandlingAction.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\CommandInterpreter.java
	 */


import java.util.ArrayList;
import java.util.List;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataManipulation.Add;
import dataManipulation.All;
import dataManipulation.ChangeDateType;
import dataManipulation.Command;
import dataManipulation.CommandType;
import dataManipulation.CommandType.COMMAND_TYPE;
import dataManipulation.Completed;
import dataManipulation.Edit;
import dataManipulation.Finish;
import dataManipulation.Help;
import dataManipulation.Overdue;
import dataManipulation.Redo;
import dataManipulation.Remove;
import dataManipulation.Repeat;
import dataManipulation.Search;
import dataManipulation.Subcommand;
import dataManipulation.Today;
import dataManipulation.Undo;
import dataManipulation.Unfinish;

public class CommandInterpreter {
	private static CommandInterpreter commandInterpreter;

	private CommandInterpreter() {
	}

	public static CommandInterpreter getInstance() {
		if (commandInterpreter == null) {
			commandInterpreter = new CommandInterpreter();
		}
		return commandInterpreter;
	}

	public Command formCommand(String input) throws BadCommandException, 
		BadSubcommandException, BadSubcommandArgException {
		assert (input != null);
		if (input.isEmpty()) {
			throw new BadCommandException("no command given");
		}

		if (isSpecialCommand(input)) {
			Command command = determineSpecialCommand(input);
			return command;
		}

		String commandTypeString = getFirstWord(input);
		COMMAND_TYPE commandType = 
				CommandType.determineCommandType(commandTypeString);
		Command command;

		List<Subcommand> components;

		if (isNoComponentCommand(commandType)) {
			components = getNoSubcommands(input);
		} else {
			input = removeFirstWord(input);
			components = getComponents(input, commandType);
		}

		command = makeCommand(commandType, components);

		return command;
	}

	// -----------------------------------------------------------------------------
	// ---------------- Command Related Methods
	// ------------------------------------
	// -----------------------------------------------------------------------------

	private Command makeCommand(COMMAND_TYPE type, List<Subcommand> subcommands) 
			throws BadCommandException, BadSubcommandException, BadSubcommandArgException {
		switch (type) {
		case ADD:
			return new Add(subcommands);
		case ALL:
			return new All(subcommands);
		case CHANGE_DATE_TYPE:
			return new ChangeDateType(subcommands);
		case COMPLETED:
			return new Completed(subcommands);
		case EDIT:
			return new Edit(subcommands);
		case FINISH:
			return new Finish(subcommands);
		case HELP:
			return new Help(subcommands);
		case OVERDUE:
			return new Overdue(subcommands);
		case REDO:
			return new Redo(subcommands);
		case REMOVE:
			return new Remove(subcommands);
		case REPEAT:
			return new Repeat(subcommands);
		case SEARCH:
			return new Search(subcommands);
		case TODAY:
			return new Today(subcommands);
		case UNDO:
			return new Undo(subcommands);
		case UNFINISH:
			return new Unfinish(subcommands);
		default:
			throw new BadCommandException("invalid command type");
		}
	}

	private boolean isSpecialCommand(String input) {
		input = input.toLowerCase();

		String[] splitInput = splitString(input);

		if (isChangeDateType(splitInput)) {
			return true;
		} else if (input.equalsIgnoreCase("help")) {
			return true;
		} else {
			return false;
		}
	}

	private boolean isChangeDateType(String[] splitInput) {
		String[] changeDateTypeExample = makeChangeDateTypeExample();

		if (splitInput.length != changeDateTypeExample.length) {
			return false;
		}

		// last element of command is a variable and not the command itself
		int commandLength = splitInput.length - 1;
		int lastPosition = splitInput.length - 1;

		for (int i = 0; i < commandLength; ++i) {
			if (!splitInput[i].equals(changeDateTypeExample[i])) {
				return false;
			}
		}

		String firstOption = "d/m";
		String secondOption = "m/d";
		String usersOption = splitInput[lastPosition];

		if (!usersOption.equals(firstOption)
				&& !usersOption.equals(secondOption)) {
			return false;
		}

		return true;
	}

	private String[] makeChangeDateTypeExample() {
		int length = 4; // "change" "date" "type" "D/M", etc
		String[] example = new String[length];

		int iterator = 0;

		example[iterator++] = "change";
		example[iterator++] = "date";
		example[iterator++] = "type";
		example[iterator++] = "d/m";

		return example;
	}

	/**
	 * assumes that input has already been checked to match the special command
	 * formats. Will only check variables.
	 * 
	 * Currently, there is only one special command, so it directly asks for
	 * "change date type d/m" at "d/m" (position index 3)
	 * 
	 * @param input
	 * @return
	 * @throws BadSubcommandException 
	 * @throws BadCommandException 
	 * @throws BadSubcommandArgException 
	 */
	private Command determineSpecialCommand(String input) 
			throws BadCommandException, BadSubcommandException, 
			BadSubcommandArgException {
		input = input.toLowerCase();
		
		if (input.matches("help")) {
			List<Subcommand> helpList = new ArrayList<Subcommand>();
			Subcommand listSubC = new Subcommand(Subcommand.TYPE.HELP, "list");
			helpList.add(listSubC);
			return new Help(helpList);
		}

		String[] splitInput = splitString(input);
		int lastPosition = splitInput.length - 1;

		Subcommand component = new Subcommand(Subcommand.TYPE.DATE_TYPE,
				splitInput[lastPosition]);

		List<Subcommand> list = new ArrayList<Subcommand>();
		list.add(component);

		Command command = new ChangeDateType(list);

		return command;
	}

	// -----------------------------------------------------------------------------
	// ------------------ Subcommand Related Methods
	// -------------------------------
	// -----------------------------------------------------------------------------

	private List<Subcommand> getComponents(String string,
			COMMAND_TYPE commandType) throws BadSubcommandArgException, BadSubcommandException {
		assert (string != null);
		assert (!string.isEmpty());

		List<Subcommand> components = new ArrayList<Subcommand>();

		// Search and Sort must label their first subcommands
		if (commandType == COMMAND_TYPE.SEARCH) {
			handleSearch(string, commandType, components);
		} else {
			string = handleInitialTitle(string, commandType, components);
			string = handleRestOfCommand(string, components);
		}

		return components;
	}

	private String handleRestOfCommand(String string,
			List<Subcommand> components) throws BadSubcommandArgException,
			BadSubcommandException, IndexOutOfBoundsException {
		Subcommand component;
		while (string.length() > 0) {
			component = getNextComponent(string);
			if (isQuotationSubcommand(component)) {
				string = eraseQuoteComponent(string);
			} else {
				string = eraseNoQuoteComponent(component, string);
			}
			components.add(component);
		}
		return string;
	}

	private void handleSearch(String string, COMMAND_TYPE commandType,
			List<Subcommand> components) throws BadSubcommandArgException,
			BadSubcommandException, IndexOutOfBoundsException {
		handleRestOfCommand(string, components);
	}

	private String handleInitialTitle(String string, COMMAND_TYPE commandType,
			List<Subcommand> components) throws BadSubcommandArgException,
			BadSubcommandException, IndexOutOfBoundsException {
		Subcommand component;
		component = getFirstComponent(commandType, string);
		if (isQuotationSubcommand(component)) {
			string = eraseQuoteComponent(string);
		} else {
			string = eraseNoQuoteComponent(component, string);
		}
		components.add(component);
		return string;
	}

	private List<Subcommand> getNoSubcommands(String input) throws 
		BadSubcommandException {
		assert (input != null);

		try {
			input = removeFirstWord(input); // will throw if there's no input
		} catch (BadSubcommandException e) {
			input = ""; // ok - just means that the command was the last one
		}

		return createNoComponent(input);
	}

	private static List<Subcommand> createNoComponent(String string) throws BadSubcommandException {
		assert (string != null);

		string = string.trim();

		if (!string.isEmpty()) {
			throw new BadSubcommandException("too many arguments");
		}

		List<Subcommand> componentList = new ArrayList<Subcommand>();

		return componentList;
	}

	private boolean isNoComponentCommand(COMMAND_TYPE commandType) {
		switch (commandType) {
		case ALL:
			return true;
		case COMPLETED:
			return true;
		case OVERDUE:
			return true;
		case REDO :
			return true;
		case TODAY:
			return true;
		case UNDO:
			return true;
		default:
			return false;
		}
	}

	/**
	 * The first component should be directly after the command type Will be
	 * surrounded by quotations if formatted correctly
	 * 
	 * Assumes that the command type has already been removed from the string
	 * 
	 * @param string
	 * @return
	 * @throws BadSubcommandArgException 
	 * @throws BadSubcommandException 
	 */
	private Subcommand getFirstComponent(COMMAND_TYPE commandType, String string) 
			throws BadSubcommandArgException, BadSubcommandException {
		string = string.trim(); // remove whitespace

		Subcommand.TYPE componentType = determineFirstComponentType(commandType);

		String componentData = getComponentData(string, componentType);

		Subcommand component = new Subcommand(componentType, componentData);
		return component;
	}

	private Subcommand.TYPE determineFirstComponentType(COMMAND_TYPE commandType) {
		switch (commandType) {
		case ADD:
			return Subcommand.TYPE.NAME;
		case EDIT:
			return Subcommand.TYPE.NAME;
		case FINISH:
			return Subcommand.TYPE.NAME;
		case HELP:
			return Subcommand.TYPE.HELP;
		case REMOVE:
			return Subcommand.TYPE.NAME;
		case REPEAT:
			return Subcommand.TYPE.NAME;
		case SEARCH:
			return Subcommand.TYPE.NAME;
		case UNFINISH:
			return Subcommand.TYPE.NAME;
		default:
			return Subcommand.TYPE.INVALID;
		}
	}

	private Subcommand getNextComponent(String componentSentence) throws 
		BadSubcommandArgException, BadSubcommandException {
		String componentTypeString = getFirstWord(componentSentence);
		Subcommand.TYPE componentType = Subcommand
				.determineComponentType(componentTypeString);

		if (!isNoArgSubcommand(componentType)) {
			componentSentence = removeFirstWord(componentSentence);
		}

		String componentData = getComponentData(componentSentence,
				componentType);

		Subcommand component = new Subcommand(componentType, componentData);
		return component;
	}

	/**
	 * Assumes that the String is not between quotation marks (which would allow
	 * the user to write subcommand keywords)
	 * 
	 * @param componentPart
	 * @return
	 */
	private boolean isSubcommand(String possibleSubcommand) {
		Subcommand.TYPE possibleType = Subcommand
				.determineComponentType(possibleSubcommand);

		if (possibleType == Subcommand.TYPE.INVALID) {
			return false;
		} else {
			return true;
		}
	}

	private String eraseNoQuoteComponent(Subcommand component, String sentence) {
		assert (sentence != null);
		assert (component != null);

		String match = extractComponentMatch(component, sentence);

		String emptyString = "";

		sentence = sentence.replaceFirst(match, emptyString);

		if (sentence.equals(match)) {
			return emptyString; // replaceFirst will not replace the entire
								// string
		}

		sentence = sentence.trim();

		return sentence;
	}

	private String eraseQuoteComponent(String sentence)
			throws IndexOutOfBoundsException, BadSubcommandArgException {
		assert (sentence != null);
		char quote = '"';

		int indexOfNextQuote = sentence.indexOf(quote);
		if (indexOfNextQuote == -1) {
			throw new BadSubcommandArgException("No double quote found");
		}

		String withoutUntilFirstQuote = sentence
				.substring(indexOfNextQuote + 1);

		indexOfNextQuote = withoutUntilFirstQuote.indexOf(quote);
		int indexOfEnd = withoutUntilFirstQuote.length() - 1;
		// if the component is the last component
		if (indexOfNextQuote == indexOfEnd) {
			String emptyString = "";
			return emptyString;
		}

		if (indexOfNextQuote == -1) {
			throw new BadSubcommandArgException("No double quote found");
		}

		String withoutUntilSecondQuote = withoutUntilFirstQuote
				.substring(indexOfNextQuote + 1);

		withoutUntilSecondQuote = withoutUntilSecondQuote.trim();

		return withoutUntilSecondQuote;
	}

	private boolean isQuotationSubcommand(Subcommand component) {
		Subcommand.TYPE type = component.getType();

		switch (type) {
		case CATEGORY:
			return true;
		case LOCATION:
			return true;
		case NAME:
			return true;
		case NOTE:
			return true;
		case TITLE:
			return true;
		default:
			return false;
		}
	}

	// -----------------------------------------------------------------------------
	// ------------------ Subcommand Data Related Methods
	// --------------------------
	// -----------------------------------------------------------------------------

	private String getComponentData(String userCommand,
			Subcommand.TYPE componentType) throws BadSubcommandArgException {
		if (isNoQuoteSubcommand(componentType) || 
				isNoArgSubcommand(componentType)) {
			return getNoQuoteComponentData(userCommand);
		}

		userCommand = userCommand.trim();
		return getBetweenQuoteData(userCommand);
	}

	private String getNoQuoteComponentData(String userCommand) {
		assert (!userCommand.isEmpty());

		String[] splitCommand = splitString(userCommand);
		String removedWhitespace = " ";

		String wholeData = splitCommand[0];
		String dataPart = new String();
		for (int i = 1; (i < splitCommand.length) && (!isSubcommand(dataPart)); ++i) {
			dataPart = splitCommand[i];
			if (!isSubcommand(dataPart)) {
				wholeData = wholeData + removedWhitespace + dataPart;
			}
		}
		wholeData = wholeData.trim();

		return wholeData;
	}

	private String getBetweenQuoteData(String userCommand)
			throws BadSubcommandArgException {
		String emptyString = "";
		String doubleQuoteMark = "\"";

		userCommand = userCommand.trim();

		checkFirstQuotation(userCommand); // first character should be a
											// quotation
		userCommand = userCommand.replaceFirst(doubleQuoteMark, emptyString);
		String commandData = getUntilQuotation(userCommand);

		return commandData;
	}

	private void checkFirstQuotation(String userCommand) throws BadSubcommandArgException {
		String doubleQuote = "\"";
		if (!userCommand.startsWith(doubleQuote)) {
			throw new BadSubcommandArgException(
					"invalid subcommand argument: double quotes");
		}
	}

	private String getUntilQuotation(String userCommand) throws BadSubcommandArgException {
		assert (userCommand != null);
		if (userCommand.isEmpty()) {
			throw new BadSubcommandArgException(
					"invalid subcommand argument: double quotes");
		}

		String fullString = userCommand.substring(0, 1);
		String singleChar = new String();
		String doubleQuote = "\"";

		for (int i = 1; (i != userCommand.length())
				&& (!singleChar.equals(doubleQuote)); ++i) {
			fullString = fullString + singleChar;
			singleChar = userCommand.substring(i, i + 1);
		}

		// check to see if it ever saw another quotation mark
		if (!singleChar.equals(doubleQuote)) {
			throw new BadSubcommandArgException(
					"invalid subcommand argument: double quotes");
		}

		return fullString;
	}

	private String extractComponentMatch(Subcommand component, String sentence) {
		String[] splitSentence = splitString(sentence);
		String matchingString = component.getContents();
		String growingMatch = splitSentence[0];
		String space = " ";

		assert (sentence.contains(matchingString));

		for (int i = 1; ((!growingMatch.contains(matchingString)) && (i < splitSentence.length)); ++i) {
			growingMatch = growingMatch.concat(space);
			growingMatch = growingMatch.concat(splitSentence[i]);
		}
		growingMatch = growingMatch.trim();

		return growingMatch;
	}
	
	private boolean isNoArgSubcommand(Subcommand.TYPE componentType) {
		switch (componentType) {
			case FREE :
				return true;
			case FREQUENCY :
				return true;
			case HELP :
				return true;
			case AND :
				return true;
			case OR :
				return true;
			default :
				return false;
		}
	}
	
	private boolean isNoQuoteSubcommand(Subcommand.TYPE type) {
		switch (type) {
			case START :
				return true;
			case END :
				return true;
			case DATE :
				return true;
			case ON :
				return true;
			case STARTTIME :
				return true;
			case ENDTIME :
				return true;
			case HELP :
				return true;
			default :
				return false;
		}
	}

	// -----------------------------------------------------------------------------
	// ------------------ General Methods
	// ------------------------------------------
	// -----------------------------------------------------------------------------

	/**
	 * Gets the first word from the string
	 * 
	 * @param sentence
	 *            with length > 0
	 * @return a String of all characters before the first whitespace (or the
	 *         end)
	 */
	private String getFirstWord(String sentence) {
		assert (sentence != null);
		assert (!sentence.isEmpty());

		String[] dividedSentence = splitString(sentence);
		String commandTypeString = dividedSentence[0];

		return commandTypeString;
	}

	/**
	 * Removes the first substring before whitespace, as well as end whitespace
	 * 
	 * @param input
	 * @return
	 * @throws BadSubcommandException 
	 */
	private String removeFirstWord(String sentence) throws BadSubcommandException {
		assert (sentence != null);

		String[] splitSentence = splitString(sentence);

		int minimumSize = 2; // must be at least 2 words in command;
		if (splitSentence.length < minimumSize) {
			throw new BadSubcommandException("too short of argument");
		}

		String shorterString = new String();
		String space = " ";
		for (int i = 1; i < splitSentence.length; ++i) {
			shorterString = shorterString.concat(space);
			shorterString = shorterString.concat(splitSentence[i]);
		}
		shorterString = shorterString.trim();

		return shorterString;
	}

	/**
	 * Splits string at whitespace.
	 * 
	 * @param toSplit
	 * @return
	 */
	private String[] splitString(String toSplit) {
		assert (toSplit != null);
		assert (!toSplit.isEmpty());
		String whiteSpace = "\\s+";

		String noEndWhitespace = toSplit.trim();

		String[] dividedString = noEndWhitespace.split(whiteSpace);

		return dividedString;
	}

}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\CommandInterpreter.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\CommandInterpreterInteractiveTester.java
	 */


import java.util.Scanner;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataManipulation.Command;

public class CommandInterpreterInteractiveTester {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(true) {
			 String newLine = sc.nextLine();
			 if(newLine.equals("exit")) {
				 sc.close();
				 System.exit(0);
			 }
			 try {
				 CommandInterpreter ci = CommandInterpreter.getInstance();
				 Command madeCommand = ci.formCommand(newLine);
				 System.out.println(madeCommand);
			 } catch (BadCommandException ex) {
				 System.out.println(ex);
			} catch (BadSubcommandException ex) {
				System.out.println(ex);
			} catch (BadSubcommandArgException ex) {
				System.out.println(ex);
			}
		}
	}
}
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\CommandInterpreterInteractiveTester.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\CommandInterpreterTest.java
	 */


import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.List;

import org.junit.Test;

import dataEncapsulation.BadCommandException;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.BadSubcommandException;
import dataManipulation.Add;
import dataManipulation.ChangeDateType;
import dataManipulation.Completed;
import dataManipulation.Subcommand;

/**
 * 
 * Search
 * 		duplicate subcommands
 * 		AND
 * 		OR
 * 		DATE (unique to Search)
 * 
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\CommandInterpreterTest.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ExceptionHandler.java
	 */


import java.awt.event.ActionEvent;
import java.util.ArrayList;
import java.util.List;

import javax.swing.AbstractAction;
import javax.swing.JLabel;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import dataEncapsulation.ActionException;
import dataEncapsulation.ActionException.ErrorLocation;
import dataEncapsulation.BadSubcommandArgException;
import dataEncapsulation.Task;
import dataManipulation.MultiCommand;
import dataManipulation.MultiEditor;
import dataManipulation.MultiFinish;
import dataManipulation.MultiRemove;
import dataManipulation.MultiUnfinish;
import dataManipulation.Repeat;
import dataManipulation.Subcommand;
import dataManipulation.TotalTaskList;
import dataManipulation.UndoRedoList;

public class ExceptionHandler {
	
	private JTextField userInput;
	private JTextArea display;
	private JLabel status;
	private ActionToggler enterToggle;
	
	private static final String quitRequest = "0";
	private static final String emptyString = " ";
	
	public ExceptionHandler(JTextField input, JLabel stat, 
			JTextArea disp, ActionToggler toggle) {
		userInput = input;
		display = disp;
		enterToggle = toggle;
		status = stat;
	}
	
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ExceptionHandler.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ExceptionHandler.java
	 */

	public ArrayList<Task> getChoices(String input, List<Task> opts) throws BadSubcommandArgException {
		input = formatInput(input);
		
		String choices[] = input.trim().split("\\s+");
		ArrayList<Task> choiceList = new ArrayList<Task>();
		try {
			for(String s : choices) {
				int i = (Integer.parseInt(s)) - 1;	// user choices start at 1
				Task cur = opts.get(i);
				choiceList.add(cur);
			}
		} catch (IndexOutOfBoundsException ex) {
			throw new BadSubcommandArgException("The number you have entered is out of range, "
					+ "please try again.");
		} catch (Exception e) {
			throw new BadSubcommandArgException("You have entered a non-numeric key, "
					+ "please enter a number.");
		}
		
		return choiceList;
	}

	private String formatInput(String input) throws BadSubcommandArgException {
		if(input.contains(",")) {
			input = input.replaceAll(",", " ");
		}
		
		if (input.contains("-")) {
			input = correctRange(input);
		}
		
		if (hasRepeats(input)) {
			throw new BadSubcommandArgException("You selected the same item "
					+ "more than once, please select again or enter 0 to quit");
		}
		return input;
	}
	
	private boolean hasRepeats(String input) {
		String[] separatedNumbers = input.split("\\n+");
		
		for (int i = 0; i < separatedNumbers.length - 1; ++i) {
			for (int j = i + 1; j < separatedNumbers.length; ++j) {
				if (separatedNumbers[i].matches(separatedNumbers[j])) {
					return true;
				}
			}
		}
		
		return false;
	}

	private String correctRange(String input) throws BadSubcommandArgException {
		String dash = "-";
		assert (input.contains(dash));
		
		String[] brokenRange = input.split(dash);
		for (int i = 0; i < brokenRange.length - 1; ++i) {
			String[] valuesLeft = brokenRange[i].split(dash);
			String[] valuesRight = brokenRange[i + 1].split(dash);
			String leftInt = getRightmostInt(valuesLeft[valuesLeft.length - 1].trim());
			String rightInt = getLeftmostInt(valuesRight[valuesRight.length - 1].trim());
			String range = makeRange(leftInt, rightInt);
			input = mergeRange(input, range, leftInt, rightInt);
		}
		
		return input;
	}

	private String getRightmostInt(String trim) throws BadSubcommandArgException {
		if (trim == null) {
			return trim;
		} else if (trim.isEmpty()) {
			throw new BadSubcommandArgException("formatting error: no"
					+ "upper bound to your range");
		}
		String whitespace = "\\s+";
		
		if (!trim.contains("\t") && !trim.contains(" ")) {
			return trim;
		}
		String[] split = trim.split(whitespace);
		return split[split.length - 1];
	}

	private String getLeftmostInt(String trim) throws BadSubcommandArgException {
		if (trim == null) {
			return trim;
		} else if (trim.isEmpty()) {
			throw new BadSubcommandArgException("formatting error: no"
					+ "lower bound to your range");
		}
		String whitespace = "\\s+";
		
		if (!trim.contains("\t") && !trim.contains(" ")) {
			return trim;
		}
		String[] split = trim.split(whitespace);
		return split[0];
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ExceptionHandler.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ExceptionHandler.java
	 */

	private String makeRange(String leftInt, String rightInt) throws BadSubcommandArgException {
		try {	
			int lower = Integer.parseInt(leftInt);
			int higher = Integer.parseInt(rightInt);
			String replacement = String.valueOf(lower);
			
			if (lower >= higher) {
				throw new BadSubcommandArgException("range lower bound is higher "
						+ "than range upper bound, please try again");
			}
			
			for (int i = lower + 1; i <= higher; ++i) {
				replacement = replacement + " " + i;
			}
			
			return replacement;
		} catch (Exception e) {
			throw new BadSubcommandArgException("Non-numeric input found, "
					+ "please try again");
		}
	}

	private String mergeRange(String input, String range, String leftInt, 
			String rightInt) throws BadSubcommandArgException {
		String dash = "-";
		String space = " ";
		
		assert (input.contains(dash));
		
		String toReplace = "\\s+" + leftInt + "\\s*" + dash + "\\s*" + 
				rightInt + "\\s+";
		String result = input.replaceAll(toReplace, space + range + space);
		
		if (!result.matches(input)) {
			return result;
		}	// else range must be at beginning or end
		
		// check beginning
		toReplace = "^" + leftInt + "\\s*" + dash + "\\s*" + 
				rightInt + "\\s+";
		result = input.replaceAll(toReplace, range + space);
		
		if (!result.matches(input)) {
			return result;
		}	// else range must be at end
		
		toReplace = "\\s+" + leftInt + "\\s*" + dash + "\\s*" + 
				rightInt + "$";
		result = input.replaceAll(toReplace, space + range);
		
		if (!result.matches(input)) {
			return result;
		}	// else range must be at both
		
		toReplace = "^" + leftInt + "\\s*" + dash + "\\s*" + 
				rightInt + "$";
		result = input.replaceAll(toReplace, range);
		
		if (!result.matches(input)) {
			return result;
		}	else {
			throw new BadSubcommandArgException("error in reading your request,"
					+ " please try again or press 0 to exit");
		}
	}

	@SuppressWarnings("serial")
	class FurtherEditer extends AbstractAction {
		List<Task> options;
		List<Subcommand> subcommands;
		
		public FurtherEditer(List<Task> opts, List<Subcommand> subs) {
			options = opts;
			subcommands = subs;
		}
		
		public void actionPerformed(ActionEvent ev)  {
			status.setText(emptyString);
			String userChoice = userInput.getText();
			ArrayList<Task> choices = new ArrayList<Task>();
			
			if (userChoice.trim().matches(quitRequest)) {
				status.setText("exit selected");
				endExceptionHandling();
				return;
			}
			
			try {
				choices = getChoices(userChoice, options);
			} catch (Exception e) {
				status.setText(e.getMessage());
				return;
			}
			
			try {
				MultiEditor editor = new MultiEditor(choices, subcommands);
				String message = editor.execute();
				display.setText("Successfully edited: \n\n" + message);
				UndoRedoList.getInstance().pushUndoCommand(editor);
				endExceptionHandling();
			} catch (Exception e) {
				System.err.println(e.getMessage());
				status.setText("error in reading your request,"
						+ " please try again or press 0 to exit");
			}
		}
	}
	
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ExceptionHandler.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ExceptionHandler.java
	 */

	@SuppressWarnings("serial")
	class FurtherDoer extends AbstractAction {
		List<Task> options;
		List<Subcommand> subcommands;
		ErrorLocation actionType;
		
		public FurtherDoer(List<Task> opts, List<Subcommand> subs, ErrorLocation type) {
			options = opts;
			subcommands = subs;
			actionType = type;
		}
		
		@SuppressWarnings("rawtypes")
		public MultiCommand getMulticommand(ArrayList<Task> choices) throws Exception {
			switch (actionType) {
			case DELETE :
				return new MultiRemove(choices);
			case FINISH :
				return new MultiFinish(choices);
			case UNFINISH :
				return new MultiUnfinish(choices);
			default :
				endExceptionHandling();
				throw new Exception("unable to execute request");
			}
		}
		
		public void actionPerformed(ActionEvent ev) {
			status.setText(emptyString);
			String userChoice = userInput.getText();
			
			if (userChoice.trim().matches(quitRequest)) {
				status.setText("exit selected");
				endExceptionHandling();
				return;
			}
			
			ArrayList<Task> choices = new ArrayList<Task>();
			
			try {
				choices = getChoices(userChoice, options);
			} catch (Exception e) {
				status.setText(e.getMessage());
				return;
			}
			
			try {
				@SuppressWarnings("rawtypes")
				MultiCommand remover = getMulticommand(choices);
				String message = remover.execute();
			
				display.setText(message);
				userInput.setText("");
				UndoRedoList.getInstance().pushUndoCommand(remover);	//Push command into UndoRedoList
				endExceptionHandling();
			} catch (Exception e) {
				status.setText("error in processing your request,"
						+ " please try again or press 0 to exit");
	
				e.printStackTrace();
			}
		}
	}
	
	public void endExceptionHandling() {
		enterToggle.setMaster();
		userInput.setText("");
	}
	
	private void setDisplayText(String message) {
		display.setText(message);
		
		int top = 0;
		display.setCaretPosition(top);
	}
}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ExceptionHandler.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ezCWindow.java
	 */


import java.awt.Dimension;
import java.awt.KeyboardFocusManager;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.util.Collections;

import javax.swing.AbstractAction;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.WindowConstants;

import dataEncapsulation.TaskFileErrorException;
import dataManipulation.TotalTaskList;
import fileIo.FileIo;

@SuppressWarnings("serial")
public class ezCWindow extends JFrame {

	private JTextField userInput;
	private JLabel headerLabel;
	private JScrollPane scroller;
	private JLabel status;
	private JTextArea display;

	final static String CANCEL_ACTION = "cancel-userInput";
	final static String ENTER_ACTION = "enter-command";
	final static String TAB_ACTION = "toggle-autocomplete";

	private TotalTaskList totalTaskList = TotalTaskList.getInstance();
	private FileIo fileIo = FileIo.getInstance();
	private ezCMessages messages = ezCMessages.getInstance();

	private static ezCWindow window;

	private ezCWindow() {
		initComponents();
	}

	public static ezCWindow getInstance() {
		if (window == null) {
			window = new ezCWindow();
		}

		return window;
	}

	private void initComponents() {
		initializeStaticMembers();

		initializeLayout();

		initializeActions();

		try {
			fileIo.initializeTaskList(totalTaskList);
		} catch (TaskFileErrorException e) {
			String errorMessage = e.getMessage() + "\n\n" + display.getText();
			display.setText(errorMessage);
			try {
				fileIo.recover(e);
			} catch (Exception failure) {
				errorMessage = e.getMessage() + "\nAttempt failed.\n\n" 
						+ messages.getUserCommandDisplay();
				display.setText(errorMessage);
			}
			errorMessage = e.getMessage() + "\nAttempt succeeded.\n\n" 
					+ messages.getUserCommandDisplay();
			display.setText(errorMessage);
		} catch (Exception e) {
			String errorMessage = "There was an error in reading your file. "
					+ "Please restart.";
			display.setText(errorMessage);
		}

		pack();
		
		setAesthetics();
	}

	private void initializeActions() {
		userInput.setFocusTraversalKeys(
				KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, 
				Collections.emptySet());
		
		ActionToggler enterToggle = new ActionToggler();
		ActionToggler tabToggle = new ActionToggler();
		ActionToggler escapeToggle = new ActionToggler();

		AutocompleteAction tabAction = new AutocompleteAction(status, userInput);
		CommandHandlingAction enterAction = new CommandHandlingAction(status, 
				display, userInput, enterToggle);
		CancelAction escAction = new CancelAction();
		
		enterToggle.initializeMaster(userInput, "ENTER", ENTER_ACTION, 
				enterAction);
		tabToggle.initializeMaster(userInput, "TAB", TAB_ACTION, tabAction);
		escapeToggle.initializeMaster(userInput, "ESCAPE", CANCEL_ACTION, 
				escAction);
		
		enterToggle.setMaster();
		tabToggle.setMaster();
		escapeToggle.setMaster();
	}

	private void initializeLayout() {
		GroupLayout layout = new GroupLayout(getContentPane());
		getContentPane().setLayout(layout);

		initializeHorizontalGroup(layout);

		initializeVerticalGroup(layout);
		
		//setAesthetics();
	}

	private void setAesthetics() {
		setWindowText();
		
		Dimension screenDimensions = Toolkit.getDefaultToolkit().getScreenSize();
		double screenWidth = screenDimensions.getWidth();
		double screenHeight = screenDimensions.getHeight();
		double scaler = 1.0/3.0;
		
		setWindowSize(scaler, screenWidth, screenHeight);
		
		setWindowPosition(scaler, screenWidth, screenHeight); 
	}

	private void setWindowText() {
		status.setText(" ");
		try {
			display.setText(messages.getWelcomeMessage() +
					messages.welcomeTaskDisplayForUser());
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		int top = 0;
		display.setCaretPosition(top);
	}

	private void setWindowPosition(double scaler, double screenWidth,
			double screenHeight) {
		int windowXPos= (int) (screenWidth*scaler/2);
		int windowYPos = (int) (screenHeight*scaler/2);
		this.setLocation(windowXPos, windowYPos);
	}

	private void setWindowSize(double scaler, double screenWidth,
			double screenHeight) {
		int windowWidth = (int) (screenWidth*2*scaler);
		int windowHeight = (int) (screenHeight*2*scaler);
		this.setSize(new Dimension(windowWidth, windowHeight));
		
		this.addComponentListener(new ComponentAdapter(){
	        public void componentResized(ComponentEvent e){
	            Dimension d= ezCWindow.this.getSize();
	            Dimension minD= ezCWindow.this.getMinimumSize();
	            if(d.width<minD.width)
	                d.width=minD.width;
	            if(d.height<minD.height)
	                d.height=minD.height;
	            ezCWindow.this.setSize(d);
	        }
	    });
	}

	private void initializeStaticMembers() {
		userInput = new JTextField();
		display = new JTextArea();
		status = new JLabel();
		headerLabel = new JLabel();

		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
		setTitle("ezC");

		display.setColumns(20);
		display.setLineWrap(true);
		display.setRows(5);
		display.setWrapStyleWord(true);
		display.setEditable(false);
		scroller = new JScrollPane(display,
		         JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
		         JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
	}

	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ezCWindow.java





	/**
	 * origin: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ezCWindow.java
	 */

	class CancelAction extends AbstractAction {
		public void actionPerformed(ActionEvent ev) {
			userInput.setText("");
			status.setText(" ");
		}
	}
	
	// End of segment: C:\Users\Kiri\Documents\ezC\name\src\userInterface\ezCWindow.java





